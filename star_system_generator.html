
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ruin System Generator (P-Type Optimized)</title>
<style>
  body { margin:0; font-family:'Segoe UI',sans-serif; background:#031018; color:#e6f1ff; display:flex; height:100vh; overflow:hidden }
  .sidebar { width:300px; background:#041924; border-right:2px solid #072839; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; gap:12px; z-index: 10; overflow-y: auto; }
  .sidebar h1{font-size:1.3em;margin:0;color:#fff}
  .sidebar label{color:#9fcbdc; margin-top: 8px; font-weight: 600; font-size: 0.9em;}
  .sidebar input, .sidebar select {width:100%;padding:8px;border-radius:6px;border:1px solid #0b3c57;background:#072839;color:#aee1ff; box-sizing: border-box;}
  .buttons{display:flex;flex-direction:column;gap:8px; margin-top: 10px;}
  button{padding:8px 12px;border-radius:6px;border:none;background:#f6c435;color:#111;font-weight:700;cursor:pointer}
  button:hover{background:#ffda66}
  #map{flex:1;cursor:grab;background:linear-gradient(180deg,#021018,#031018); will-change: transform;}
  text{font-size:11px;fill:#cfeff7;user-select:none; pointer-events: none;} /* Optimization: No pointer events on text */

  #infoPanel { width: 300px; background: #041924; border-left: 2px solid #072839; display: flex; flex-direction: column; transition: margin-right 0.3s ease; z-index: 10; }
  #infoPanel.hidden { margin-right: -300px; }
  #infoToggleBtn { padding: 8px 12px; background: #0b3c57; color: #aee1ff; border: none; cursor: pointer; font-weight: 700; }
  #infoToggleBtn:hover { background: #0e4a6d; }
  #infoListContainer { flex: 1; overflow-y: auto; padding-top: 15px; box-sizing: border-box; }
  
  #systemDescription { padding: 0 15px 15px 15px; border-bottom: 1px solid #072839; margin-bottom: 10px; }
  #systemDescription h2 { font-size: 1.3em; color: #f6c435; margin: 0 0 5px 0; }
  #systemDescription p { font-size: 0.9em; color: #b8dcec; margin: 0; line-height: 1.4; }

  #infoListContainer h2.directory-title { font-size: 1.2em; color: #fff; margin: 0 15px 10px 15px; border-bottom: 1px solid #072839; padding-bottom: 5px; }
  #infoList { list-style: none; padding: 0 15px; margin: 0; }
  #infoList > li { margin-bottom: 8px; }
  .info-header { background: #072839; padding: 6px 10px; border-radius: 4px; font-size: 0.9em; font-weight: 600; color: #cfeff7; }
  .info-header.collapsible { cursor: pointer; color: #fff; }
  .info-header.collapsible:hover { background: #0b3c57; }
  .info-header.collapsible::before { content: '+ '; font-weight: bold; color: #f6c435; }
  .info-header.collapsible.expanded::before { content: '- '; }
  .info-sublist { list-style: none; padding: 5px 0 0 15px; margin: 0; font-size: 0.85em; display: none; }
  .info-sublist.visible { display: block; }
  .info-sublist li { position: relative; padding-left: 15px; margin-top: 4px; color: #b8dcec; }
  .info-sublist li::before { content: 'â””'; position: absolute; left: 0; top: -2px; color: #0b3c57; }
</style>
</head>
<body>
  <div class="sidebar">
    <h1>Ruin System Generator</h1>
    
    <label for="systemType">System Configuration</label>
    <select id="systemType">
        <option value="binary">Binary Star (P-Type Orbits)</option>
        <option value="single">Single Star (Standard)</option>
    </select>

    <label for="seedInput">Seed</label>
    <input id="seedInput" placeholder="Enter seed (e.g. S12345)" />
    
    <div class="buttons">
      <button id="generateBtn">Generate System</button>
      <button id="randomSeedBtn">Random Seed</button>
      <button id="toggleLabelsBtn">Toggle Labels</button>
    </div>
    <small style="color:#86a7ad; margin-bottom: 10px;">Drag to pan, scroll to zoom.</small>
    <label for="generatedDataList">System Data Log</label>
    <textarea id="generatedDataList" rows="12" style="width:100%;background:#072839;color:#aee1ff;border:1px solid #0b3c57;border-radius:6px;font-size:0.8em; box-sizing: border-box;" readonly placeholder="Generated data..."></textarea>
  </div>
  <svg id="map" viewBox="-1500 -1500 3000 3000" xmlns="http://www.w3.org/2000/svg" aria-label="Ruin system map"></svg>
  <div id="infoPanel">
    <button id="infoToggleBtn">Toggle Panel</button>
    <div id="infoListContainer">
      <div id="systemDescription">
        <h2 id="systemNameLabel">System: ...</h2>
        <p id="systemInfoText">Generating system data...</p>
      </div>
      <h2 class="directory-title">System Directory</h2>
      <ul id="infoList"></ul>
    </div>
  </div>
<script>
const CONFIG = {
    modes: {
        single: {
            viewBox: { x: -2000, y: -2000, w: 4000, h: 4000 },
            countMultiplier: 1.0,
            starCount: 1,
            maxRangeMultiplier: 1.0,
            instabilityRadius: 200 // Standard radiation
        },
        binary: {
            viewBox: { x: -3500, y: -3500, w: 7000, h: 7000 },
            countMultiplier: 1.8,
            starCount: 2,
            maxRangeMultiplier: 1.6,
            instabilityRadius: 600 // Large P-Type instability zone
        }
    },

    planetTypes: ['Volcanic','Oceanic','Ice','Gas','Crystalline','Jungle','Desert','Artificial','Toxic','Shadow','Radiant','Coral','Storm','Barren','Frozen','Magma','Arid',
                  'Tidal-Locked','Ringed World','Tesseract','Neutronium Core','Terraformed','Cybernetic','Rogue Planet','Ecumenopolis','Void-Wreck','Shattered','Relic Station',
                  'Ruined Ecumenopolis', 'Forge World', 'Dead Archive', 'Phase-World', 'Karst World', 'Mycelial', 'Archipelago', 'Chrono-Locked', 'Prism-World'],
    planetRoots: ['Koraon','Erebus','Nalara','Zephyra','Tarkon','Virella','Dravon','Solara','Elios','Thalor','Maren','Kythera','Rhegan','Velara','Xenon','Orpheus','Lythera','Zanros','Pereon','Vastor','Aelion','Boreas','Caelos','Vindra','Morthan','Seren','Ulyra','Tirion',
            'Cygnus','Aether','Stygia','Chronos','Andromeda','Nebula','Kryll','Jovian','Rylos','Galactic','Astra','Hyperion','Veridian','Nova','Zydar','Onyx','Sagan',
            'Proxima', 'Alpha-C', 'Beta-G', 'Sector-9', 'Rift', 'Aegis', 'Heliopax', 'Gliese', 'Trappist', 'Kepler', 'Odysseus', 'Procyon', 'Altair'],
    
    ruinFactions: ['Nova Clan', 'Varkhal Dominion', 'Thalor Ascendancy', 'Eclipsera Directorate'],
    celestialFactions: ['Celestial Consortium'],
    
    ruinPrefixes: ['Military Post', 'Depot', 'Transit Post', 'Warp Research Center', 'Weapon Research Center', 'Spatial Institute', 'Listening Post', 'Comms Relay', 'Archive', 'Supply Cache', 'Garrison', 'Patrol Point', 'Sensor Hub', 'Nav-Buoy', 'Scrap Yard', 'Containment', 'Bio-Vat'],
    largeRuinPrefixes: ['City Ruins', 'Military Base', 'Large Shipyard', 'Command Center', 'Fortification', 'Assembly Yard', 'Sector HQ', 'Ecumenopolis Ruins', 'Database Core', 'Fortress Ruins'],
    shipyardPrefixes: ['Orbital Shipyard', 'Fleet Drydock', 'Construction Yard', 'Naval Assembly', 'Vessel Foundry', 'Starship Works', 'Capital Yard'],
    depotPrefixes: ['Defense Depot', 'Auth. Turret', 'Gun Platform', 'Ordnance Cache', 'Sentry Post', 'Fire Control'],
    consortiumPrefixes: ['Exploration Hub', 'Pioneer Station', 'Wayfinder Station', 'Survey Post', 'Stellar Cartography', 'Deep-Space Relay'],
    autoShipyardPrefixes: ['Automated Yard', 'Drone Fabricator', 'Assembly Swarm', 'Vessel Printer'],

    ruinColors: ['#6a6a6a','#505050','#7a6a5a','#5a7a6a'],
    largeRuinColor: ['#a0a0a0'],
    planetaryRuinColor: ['#888877'],
    shipyardColor: ['#8a9aab'],
    depotColor: ['#b8dcec', '#a9d0db', '#c9e2ea'],
    stargateColor: '#9effde',
    consortiumColor: ['#b99fff'],
    autoShipyardColor: ['#a0a0a0'],
    radiationColor: 'rgba(255, 100, 50, 0.15)',
    instabilityColor: 'rgba(255, 50, 50, 0.1)', // New color for P-Type instability
    
    systemNames: ['Orionis', 'Pleiades Sector', 'Rift-Alpha', 'Astra-9', 'Nebula-Veridian', 'Erebus-Pass', 'Hyperion-Gate', 'Koraon-Expanse', 'Vesper-Reach', 'Andromeda-C-3', 'Stygia-Nexus'],
    quirk_discovery: ['a routine survey mission', 'a miscalculated FTL jump', 'following garbled ancient charts', 'a desperate escape from pirates', 'a long-range sensor ghost', 'a classified military probe', 'the last transmission of a lost freighter'],
    quirk_feature: ['a high concentration of rare isotopes', 'unusual gravimetric distortions', 'a perfectly preserved Precursor artifact', 'a system-wide debris field from an ancient battle', 'a strategically vital chokepoint', 'a unique quantum resonance', 'the only known source of Aetherium', 'a stable wormhole anomaly', 'a colossal derelict ship of unknown origin'],
    quirk_situation: ['is now a treacherous field of debris', 'is a forbidden research zone', 'is picked over by scavengers', 'is rumored to hold deep-space horrors', 'is under strict quarantine', 'is a major scavenger staging ground', 'is a protected neutral zone', 'is prohibitively dangerous to navigate', 'is considered a cursed system'],
    
    discoveryYear: (rng) => Math.floor(rng() * 200) + 2250,
    
    planetColorMap: {
        'Volcanic': '#E74C3C', 'Oceanic': '#3498DB', 'Ice': '#F2F3F4', 'Gas': '#F1C40F', 'Crystalline': '#A569BD', 'Jungle': '#27AE60', 'Desert': '#D35400', 'Artificial': '#9B59B6',
        'Toxic': '#8E44AD', 'Shadow': '#34495E', 'Radiant': '#FEFDFE', 'Coral': '#FF6B6B', 'Storm': '#7D97A0', 'Barren': '#9E9D9B', 'Frozen': '#B2DFFC', 'Magma': '#F39C12',
        'Arid': '#E67E22', 'Tidal-Locked': '#2ECC71', 'Ringed World': '#FAD7A0', 'Tesseract': '#117864', 'Neutronium Core': '#2C3E50', 'Terraformed': '#2ECC71',
        'Cybernetic': '#1ABC9C', 'Rogue Planet': '#5D6D7E', 'Ecumenopolis': '#BDC3C7', 'Void-Wreck': '#4A4E51', 'Shattered': '#A1887F', 'Relic Station': '#797D7F',
        'Ruined Ecumenopolis': '#707B7C', 'Forge World': '#E67E22', 'Dead Archive': '#AAB7B8', 'Phase-World': '#AF7AC5', 'Karst World': '#CACFD2', 'Mycelial': '#D2B4DE',
        'Archipelago': '#48C9B0', 'Chrono-Locked': '#FAD7A0', 'Prism-World': '#E8DAEF', 'default': '#95A5A6'
    },

    // Generation parameters (Resized for P-Orbits)
    planet: {
        count: (rng) => 5 + Math.floor(rng() * 4),
        minOrbit: 350, // Base orbit, overridden by mode
        orbitStep: 220, orbitVariance: 60,
        minRadius: 25, radiusVariance: 10, clusterRadius: 40
    },
    planetaryRuin: {
        count: (rng) => 1 + Math.floor(rng() * 3),
        minDist: 60, distVariance: 60, size: 12,
        subRuinCount: (rng) => 2 + Math.floor(rng() * 4),
        subRuinMinDist: 35, subRuinDistVariance: 30
    },
    scatteredRuin: {
        count: (rng) => 15 + Math.floor(rng() * 10),
        size: 10, minRange: 800, maxRange: 3500,
    },
    largeRuin: { 
        count: (rng) => 1 + Math.floor(rng() * 2),
        size: 30, minRange: 1500, maxRange: 3000,
        subRuinCount: (rng) => 8 + Math.floor(rng() * 7),
        subRuinMinDist: 70, subRuinDistVariance: 80,
    },
    shipyard: { 
        count: 5,
        size: 25, minRange: 1200, maxRange: 2800,
        subRuinCount: (rng) => 10 + Math.floor(rng() * 5),
        subRuinMinDist: 60, subRuinDistVariance: 60
    },
    stargate: {
        size: 40, minRange: 2200, maxRange: 3800,
        securityCount: 2,
        securitySize: 15,
        securityMinDist: 80, securityDistVariance: 30
    },
    consortiumStation: {
        count: (rng) => 5 + Math.floor(rng() * 4),
        size: 20, minRange: 800, maxRange: 3000,
    },
    factionFortressData: {
        'Nova Clan': {
            faction: ['Nova Clan'],
            prefixes: ['Armed Fortress', 'Sector Command', 'Watchtower Prime'],
            color: '#cc8888',
            size: 25, minRange: 1300, maxRange: 2800,
            subClusters: [
                { type: 'Defense Depot', shape: 'triangle', colors: ['#b8dcec'], prefixes: ['Defense Depot', 'Auth. Turret'], count: (rng) => 12 + Math.floor(rng() * 6), minDist: 70, distVariance: 60, size: 8 }
            ]
        },
        'Varkhal Dominion': {
            faction: ['Varkhal Dominion'],
            prefixes: ['System Citadel', 'Central Depot', 'Gorgon Station'],
            color: '#88cc88',
            size: 25, minRange: 1300, maxRange: 2800,
            subClusters: [
                { type: 'Defense Depot', shape: 'triangle', colors: ['#b8dcec'], prefixes: ['Gun Platform', 'Sentry Post'], count: (rng) => 12 + Math.floor(rng() * 6), minDist: 70, distVariance: 60, size: 8 }
            ]
        },
        'Thalor Ascendancy': {
            faction: ['Thalor Ascendancy'],
            prefixes: ['Void Bastion', 'Aegis Station', 'Research Institute'],
            color: '#8888cc',
            size: 25, minRange: 1300, maxRange: 2800,
            subClusters: [
                { type: 'Defense Depot', shape: 'triangle', colors: ['#b8dcec'], prefixes: ['Ordnance Cache', 'Fire Control'], count: (rng) => 12 + Math.floor(rng() * 6), minDist: 70, distVariance: 60, size: 8 }
            ]
        },
        'Eclipsera Directorate': {
            faction: ['Eclipsera Directorate'],
            prefixes: ['Defense Platform', 'Energy Research Institute', 'Sector Command'],
            color: '#cccc88',
            size: 25, minRange: 1300, maxRange: 2800,
            subClusters: [
                { type: 'Defense Depot', shape: 'triangle', colors: ['#b8dcec'], prefixes: ['Defense Depot', 'Sentry Post'], count: (rng) => 12 + Math.floor(rng() * 6), minDist: 70, distVariance: 60, size: 8 }
            ]
        },
        'The Aurelion': {
            faction: ['The Aurelion'],
            prefixes: ['Aurelion Citadel', 'Sun-Forge', 'Radiant Bastion', 'Golden Aegis'],
            color: '#ffe57a',
            size: 28, minRange: 1300, maxRange: 2800,
            subClusters: [
                { type: 'Defense Depot', shape: 'triangle', colors: ['#b8dcec'], prefixes: ['Auth. Turret', 'Gun Platform'], count: (rng) => 14 + Math.floor(rng() * 6), minDist: 75, distVariance: 60, size: 8 }
            ]
        },
        'Obsidian Legion': {
            faction: ['Obsidian Legion'],
            prefixes: ['Obsidian Keep', 'Legion Stronghold', 'Void-Forge', 'Shadow Bastion'],
            color: '#7dff7a',
            size: 28, minRange: 1300, maxRange: 2800,
            subClusters: [
                { type: 'Defense Depot', shape: 'triangle', colors: ['#b8dcec'], prefixes: ['Defense Depot', 'Fire Control'], count: (rng) => 10 + Math.floor(rng() * 5), minDist: 75, distVariance: 60, size: 8 },
                { type: 'Automated Shipyard', shape: 'rect', colors: ['#a0a0a0'], prefixes: ['Automated Yard', 'Drone Fabricator'], count: (rng) => 3 + Math.floor(rng() * 3), minDist: 90, distVariance: 40, size: 12 }
            ]
        }
    }
};

// OPTIMIZATION: Spatial Hash for fast collision checks
class SpatialHash {
    constructor(cellSize) {
        this.cellSize = cellSize;
        this.grid = new Map();
    }
    getKey(x, y) { return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`; }
    add(x, y, r, obj) {
        const key = this.getKey(x, y);
        if (!this.grid.has(key)) this.grid.set(key, []);
        this.grid.get(key).push({ ...obj, x, y, r });
    }
    getCandidates(x, y) {
        const candidates = [];
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const key = `${cx + i},${cy + j}`;
                if (this.grid.has(key)) this.grid.get(key).forEach(o => candidates.push(o));
            }
        }
        return candidates;
    }
    clear() { this.grid.clear(); }
}

class RuinSystemGenerator {
    constructor(svgElement, domElements) {
        this.svg = svgElement;
        this.dom = domElements;
        this.rng = () => 0;
        this.spatialHash = new SpatialHash(150); 
        this.placedObjects = [];
        this.systemData = [];
        this.viewBox = { x: -2000, y: -2000, w: 4000, h: 4000 };
        this.isPanning = false;
        this.startPoint = { x: 0, y: 0 };
        this.panStartRect = null; 
        this.rafId = null;
        this.labelsVisible = true;
        this.systemName = '...';
        this.currentMode = 'single';

        // OPTIMIZATION: String buffers instead of DOM Fragments
        this.svgBuffers = {
            radiation: [],
            orbits: [],
            planets: [],
            stations: [],
            ruins: [],
            labels: []
        };
        
        this.svgGroups = {
            radiation: this.createEl('g', { id: 'radiationGroup' }),
            orbits: this.createEl('g', { id: 'orbitsGroup' }),
            planets: this.createEl('g', { id: 'planetsGroup' }),
            stations: this.createEl('g', { id: 'stationsGroup' }),
            ruins: this.createEl('g', { id: 'ruinsGroup' }),
            labels: this.createEl('g', { id: 'labelsGroup' })
        };
        
        Object.values(this.svgGroups).forEach(group => this.svg.appendChild(group));
    }

    init() {
        this.bindUIListeners();
        this.bindMapListeners();
        this.dom.seedInput.value = 'S' + Math.floor(Math.random() * 900000 + 100000);
        this.generate();
    }

    bindUIListeners() {
        this.dom.generateBtn.addEventListener('click', () => this.generate());
        this.dom.randomSeedBtn.addEventListener('click', () => {
            this.dom.seedInput.value = 'S' + Math.floor(Math.random() * 900000 + 100000);
            this.generate();
        });
        this.dom.toggleLabelsBtn.addEventListener('click', () => this.toggleLabels());
        this.dom.infoToggleBtn.addEventListener('click', () => {
            this.dom.infoPanel.classList.toggle('hidden');
        });
    }

    generate() {
        this.clear();
        const seed = this.dom.seedInput.value || 'default';
        this.rng = this.seededRNG(seed);
        
        const modeKey = this.dom.systemType ? this.dom.systemType.value : 'single';
        this.currentMode = modeKey;
        const modeConfig = CONFIG.modes[modeKey];
        
        this.viewBox = { ...modeConfig.viewBox };
        this.updateViewBox();

        // Generate P-Type Binary Stars & Radiation Zones
        this.generateStars(modeConfig);

        const mult = modeConfig.countMultiplier;
        const rangeMult = modeConfig.maxRangeMultiplier;

        const planetClusters = this.generatePlanets(modeConfig);
        this.generatePlanetaryRuins(planetClusters, mult);
        this.generateScatteredRuins(mult, rangeMult);
        this.generateLargeRuinSites(mult, rangeMult);
        this.generateShipyards(mult, rangeMult);
        this.generateFactionFortresses(rangeMult);
        this.generateStargate(rangeMult);
        this.generateConsortiumStations(mult, rangeMult);
        
        this.generateSystemDescription(); 
        
        // OPTIMIZATION: Bulk Render from string buffers
        this.renderBuffers();

        this.populateInfoPanel();
        this.populateDataList();
    }

    clear() {
        // Clear DOM groups
        Object.values(this.svgGroups).forEach(group => group.innerHTML = '');
        // Clear Buffers
        Object.keys(this.svgBuffers).forEach(key => this.svgBuffers[key] = []);
        
        this.spatialHash.clear();
        this.placedObjects = [];
        this.systemData = [];
        this.dom.infoList.innerHTML = '';
        this.dom.dataList.value = '';
        this.dom.systemNameLabel.textContent = 'System: ...';
        this.dom.systemInfoText.textContent = 'Generating system data...';
    }

    renderBuffers() {
        Object.keys(this.svgGroups).forEach(key => {
            // Join string array and set innerHTML once
            this.svgGroups[key].innerHTML = this.svgBuffers[key].join('');
        });
    }

    generateStars(modeConfig) {
        const starRadius = 40;
        const instabilityRadius = modeConfig.instabilityRadius;
        
        if (modeConfig.starCount === 1) {
            this.drawShape('circle', 0, 0, starRadius, { fill: '#fff29f', stroke: '#ffaa00', 'stroke-width': 2 }, 'orbits');
            this.drawShape('circle', 0, 0, instabilityRadius, { fill: CONFIG.radiationColor, stroke: 'none' }, 'radiation');
            this.reserve(0, 0, instabilityRadius);
        } else {
            // P-Type Binary Configuration
            const separation = 120;
            
            // Star A
            this.drawShape('circle', -separation, 0, starRadius, { fill: '#ffdf9f', stroke: '#ff8800', 'stroke-width': 2 }, 'orbits');
            
            // Star B
            this.drawShape('circle', separation, 0, starRadius * 0.9, { fill: '#9fefff', stroke: '#00ccff', 'stroke-width': 2 }, 'orbits');
            
            // P-Type Instability Zone (Circumbinary)
            // Visualized as a large dashed area where orbits are unstable
            this.drawShape('circle', 0, 0, instabilityRadius, { fill: CONFIG.instabilityColor, stroke: '#ff4444', 'stroke-width': 2, 'stroke-dasharray': '10 10', 'fill-opacity': 0.1 }, 'radiation');
            
            this.reserve(0, 0, instabilityRadius); // Reserve entire unstable center
        }
    }

    generateSystemDescription() {
        const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
        const systemDesignation = (Math.floor(this.rng() * 90) + 10) + '-' + this.choice(letters);
        this.systemName = this.choice(CONFIG.systemNames) + " " + systemDesignation;
        const type = this.currentMode === 'binary' ? 'Binary P-Type System' : 'Star System';
        
        const year = CONFIG.discoveryYear(this.rng);
        const discoveringFaction = this.choice(CONFIG.ruinFactions);
        const discovery = this.choice(CONFIG.quirk_discovery);
        const feature = this.choice(CONFIG.quirk_feature);
        const situation = this.choice(CONFIG.quirk_situation);
        
        const description = `The ${this.systemName} is a ${type}. Discovered in ${year} by the ${discoveringFaction} following ${discovery}, it is notable for ${feature}. Today, the system ${situation}.`;
        
        this.dom.systemNameLabel.textContent = `System: ${this.systemName}`;
        this.dom.systemInfoText.textContent = description;
    }

    generatePlanets(modeConfig) {
        const C = CONFIG.planet;
        const numPlanets = Math.floor(C.count(this.rng) * modeConfig.countMultiplier);
        let planetClusters = [];
        
        // Ensure P-Type orbits start outside instability zone
        const baseOrbit = Math.max(C.minOrbit, modeConfig.instabilityRadius + 100);

        for (let i = 0; i < numPlanets; i++) {
            const type = this.choice(CONFIG.planetTypes);
            const name = this.choice(CONFIG.planetRoots) + '-' + (Math.floor(this.rng() * 900) + 100);
            
            const orbit = baseOrbit + i * C.orbitStep + Math.floor(this.rng() * C.orbitVariance);
            
            this.drawOrbit(orbit);
            let px, py;
            let tries = 0;
            do {
                const a = this.rng() * Math.PI * 2;
                px = Math.cos(a) * orbit;
                py = Math.sin(a) * orbit;
                tries++;
            } while (this.collides(px, py, C.clusterRadius) && tries < 50);
            
            this.reserve(px, py, C.clusterRadius);
            const radius = C.minRadius + this.rng() * C.radiusVariance;
            
            const color = CONFIG.planetColorMap[type] || CONFIG.planetColorMap['default'];
            
            this.drawShape('circle', px, py, radius, { fill: color }, 'planets');
            const planetName = `${name} (${type})`;
            this.drawText(px + radius + 5, py + 5, planetName);
            const planetData = { name: planetName, type: 'Planet', structures: [] };
            this.systemData.push(planetData);
            planetClusters.push({ x: px, y: py, name: name, data: planetData });
        }
        return planetClusters;
    }

    generatePlanetaryRuins(planetClusters, multiplier) {
        const C = CONFIG.planetaryRuin;
        planetClusters.forEach(p => {
            const numRuins = Math.floor(C.count(this.rng) * multiplier); 
            for (let c = 0; c < numRuins; c++) {
                const pos = this.findOpenSpot(p.x, p.y, C.size, C.minDist, C.distVariance);
                if (pos) {
                    const color = this.choice(CONFIG.planetaryRuinColor);
                    const faction = [this.choice(CONFIG.ruinFactions)];
                    const ruinName = this.genRuinName(CONFIG.ruinPrefixes, faction);
                    this.drawShape('rect', pos.x, pos.y, C.size, { fill: color }, 'ruins');
                    this.drawText(pos.x + C.size + 2, pos.y, ruinName);
                    const ruinData = { name: ruinName, type: 'Planetary Ruin', structures: [] };
                    p.data.structures.push(ruinData); 
                    this.genSubCluster(pos.x, pos.y, ruinData, 'Ruin', C.subRuinCount(this.rng), 
                        C.subRuinMinDist, C.subRuinDistVariance, 3, CONFIG.ruinPrefixes, 'rect', CONFIG.ruinColors, faction);
                }
            }
        });
    }

    generateScatteredRuins(multiplier, rangeMult) {
        const C = CONFIG.scatteredRuin;
        const numRuins = Math.floor(C.count(this.rng) * multiplier);
        const maxRange = C.maxRange * rangeMult;
        
        for (let i = 0; i < numRuins; i++) {
            const pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 50);
            if (pos) {
                const color = this.choice(CONFIG.ruinColors);
                const ruinName = this.genRuinName(CONFIG.ruinPrefixes);
                this.drawShape('rect', pos.x, pos.y, C.size, { fill: color }, 'ruins');
                this.drawText(pos.x + C.size + 2, pos.y, ruinName);
                const ruinData = { name: ruinName, type: 'Deep-Space Ruin', structures: [] };
                this.systemData.push(ruinData);
            }
        }
    }

    generateLargeRuinSites(multiplier, rangeMult) {
        const C = CONFIG.largeRuin;
        const numSites = Math.floor(C.count(this.rng) * multiplier);
        const maxRange = C.maxRange * rangeMult;

        for (let i = 0; i < numSites; i++) {
            const pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 50);
            if (!pos) continue;
            
            const faction = [this.choice(CONFIG.ruinFactions)];
            const ruinName = this.genRuinName(CONFIG.largeRuinPrefixes, faction);
            
            this.drawShape('polygon', pos.x, pos.y, C.size, { fill: this.choice(CONFIG.largeRuinColor), stroke: '#cccccc', 'stroke-width': 2, sides: 6 }, 'stations');
            this.drawText(pos.x + C.size + 2, pos.y, ruinName);
            const ruinData = { name: ruinName, type: 'Large Ruin', structures: [] };
            this.systemData.push(ruinData);
            
            this.genSubCluster(pos.x, pos.y, ruinData, 'Ruin', C.subRuinCount(this.rng),
                C.subRuinMinDist, C.subRuinDistVariance, 4, CONFIG.ruinPrefixes, 'rect', CONFIG.ruinColors, faction);
        }
    }

    generateShipyards(multiplier, rangeMult) {
        const C = CONFIG.shipyard;
        const count = Math.floor(C.count * multiplier);
        const maxRange = C.maxRange * rangeMult;

        for (let i = 0; i < count; i++) {
            const pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 50);
            if (!pos) continue;
            
            const faction = [this.choice(CONFIG.ruinFactions)];
            const ruinName = this.genRuinName(CONFIG.shipyardPrefixes, faction);
            
            this.drawShape('rect', pos.x, pos.y, C.size, { fill: this.choice(CONFIG.shipyardColor), stroke: '#aabbee', 'stroke-width': 2 }, 'stations');
            this.drawText(pos.x + C.size + 2, pos.y, ruinName);
            const ruinData = { name: ruinName, type: 'Shipyard', structures: [] };
            this.systemData.push(ruinData);
            
            this.genSubCluster(pos.x, pos.y, ruinData, 'Defense Depot', C.subRuinCount(this.rng),
                C.subRuinMinDist, C.subRuinDistVariance, 4, CONFIG.depotPrefixes, 'triangle', CONFIG.depotColor, faction);
        }
    }

    generateFactionFortresses(rangeMult) {
        for (const factionName in CONFIG.factionFortressData) {
            const C = CONFIG.factionFortressData[factionName];
            const maxRange = C.maxRange * rangeMult;
            const pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 50);
            if (!pos) continue;
            
            const fortressName = this.genRuinName(C.prefixes, C.faction);
            
            this.drawShape('polygon', pos.x, pos.y, C.size, { fill: C.color, stroke: '#ffaaaa', 'stroke-width': 3, sides: 5 }, 'stations');
            this.drawText(pos.x + C.size + 2, pos.y, fortressName);
            const fortressData = { name: fortressName, type: 'Fortress', structures: [] };
            this.systemData.push(fortressData);
            
            C.subClusters.forEach(sc => {
                this.genSubCluster(pos.x, pos.y, fortressData, sc.type, sc.count(this.rng),
                    sc.minDist, sc.distVariance, sc.size, sc.prefixes, sc.shape, sc.colors, C.faction, "", (sc.shape === 'polygon' ? 6 : 4));
            });
        }
    }

    generateStargate(rangeMult) {
        const C = CONFIG.stargate;
        const maxRange = C.maxRange * rangeMult;
        const pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 50);
        if (!pos) return;

        this.drawShape('triangle', pos.x, pos.y, C.size, { fill: 'none', stroke: CONFIG.stargateColor, 'stroke-width': 3 }, 'stations');
        const sgName = `${this.systemName} Stargate`;
        this.drawText(pos.x + C.size + 2, pos.y, sgName);
        const sgData = { name: sgName, type: 'Stargate', structures: [] };
        this.systemData.push(sgData);

        for (let i = 0; i < C.securityCount; i++) {
            const secPos = this.findOpenSpot(pos.x, pos.y, C.securitySize, C.securityMinDist, C.securityDistVariance);
            if (secPos) {
                this.drawShape('diamond', secPos.x, secPos.y, C.securitySize, { fill: this.choice(CONFIG.consortiumColor), stroke: '#d7c7ff', 'stroke-width': 2 }, 'stations');
                const secName = this.genRuinName(CONFIG.consortiumPrefixes, CONFIG.celestialFactions);
                this.drawText(secPos.x + C.securitySize + 2, secPos.y, secName);
                sgData.structures.push({ name: secName, type: 'Active Station', structures: [] });
            }
        }
    }

    generateConsortiumStations(multiplier, rangeMult) {
        const C = CONFIG.consortiumStation;
        const count = Math.floor(C.count(this.rng) * multiplier);
        const maxRange = C.maxRange * rangeMult;
        
        for (let i = 0; i < count; i++) {
            const pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 50);
            if (pos) {
                this.drawShape('diamond', pos.x, pos.y, C.size, { fill: this.choice(CONFIG.consortiumColor), stroke: '#d7c7ff', 'stroke-width': 2 }, 'stations');
                const stationName = this.genRuinName(CONFIG.consortiumPrefixes, CONFIG.celestialFactions);
                this.drawText(pos.x + C.size + 2, pos.y, stationName);
                const stationData = { name: stationName, type: 'Active Station', structures: [] };
                this.systemData.push(stationData);
            }
        }
    }

    genSubCluster(cx, cy, parentData, type, count, minDist, distVariance, size, namePrefixes, shape, colors, factionList, nameSuffix = "", shapeSides = 4) {
        for (let i = 0; i < count; i++) {
            const pos = this.findOpenSpot(cx, cy, size, minDist, distVariance);
            if (pos) {
                const color = this.choice(colors);
                const name = this.genRuinName(namePrefixes, factionList);
                this.drawShape(shape, pos.x, pos.y, size, { fill: color, sides: shapeSides }, 'ruins');
                this.drawText(pos.x + size + 2, pos.y, name, true);
                if (parentData) parentData.structures.push({ name: name, type: type, structures: [] });
            }
        }
    }

    populateInfoPanel() {
        const typeOrder = ['Stargate', 'Planet', 'Fortress', 'Shipyard', 'Large Ruin', 'Active Station', 'Planetary Ruin', 'Deep-Space Ruin', 'Ruin', 'Defense Depot', 'Automated Shipyard'];
        this.systemData.sort((a, b) => {
            let aIndex = typeOrder.indexOf(a.type), bIndex = typeOrder.indexOf(b.type);
            if (aIndex === -1) aIndex = 99;
            if (bIndex === -1) bIndex = 99;
            if (aIndex !== bIndex) return aIndex - bIndex;
            return a.name.localeCompare(b.name);
        });
        const fragment = document.createDocumentFragment();
        this.systemData.forEach(item => {
            const li = document.createElement('li');
            const header = document.createElement('div');
            header.className = 'info-header';
            header.textContent = `[${item.type}] ${item.name}`;
            li.appendChild(header);
            if (item.structures && item.structures.length > 0) {
                header.classList.add('collapsible');
                const sublist = document.createElement('ul');
                sublist.className = 'info-sublist';
                item.structures.sort((a, b) => {
                    let aIndex = typeOrder.indexOf(a.type), bIndex = typeOrder.indexOf(b.type);
                    if (aIndex === -1) aIndex = 99;
                    if (bIndex === -1) bIndex = 99;
                    if (aIndex !== bIndex) return aIndex - bIndex;
                    return a.name.localeCompare(b.name);
                });
                item.structures.forEach(subItem => sublist.appendChild(this.createInfoSubItem(subItem)));
                li.appendChild(sublist);
                header.addEventListener('click', () => {
                    sublist.classList.toggle('visible');
                    header.classList.toggle('expanded');
                });
            }
            fragment.appendChild(li);
        });
        this.dom.infoList.appendChild(fragment);
    }

    createInfoSubItem(item) {
        const li = document.createElement('li');
        li.textContent = `[${item.type}] ${item.name}`;
        if (item.structures && item.structures.length > 0) {
            const subSubList = document.createElement('ul');
            item.structures.sort((a,b) => a.name.localeCompare(b.name));
            item.structures.forEach(subSubItem => subSubList.appendChild(this.createInfoSubItem(subSubItem)));
            li.appendChild(subSubList);
        }
        return li;
    }

    populateDataList() {
        let major = [], minor = [];
        const majorTypes = ['Large Ruin', 'Shipyard', 'Fortress', 'Planet', 'Planetary Ruin', 'Stargate', 'Active Station'];
        const minorTypes = ['Deep-Space Ruin', 'Ruin', 'Defense Depot', 'Automated Shipyard'];

        const scanItem = (item) => {
            if (majorTypes.includes(item.type)) {
                if (item.type !== 'Planet') {
                    major.push(item.name);
                }
            } else if (minorTypes.includes(item.type)) {
                minor.push(item.name);
            }
            
            if (item.structures) item.structures.forEach(scanItem);
        };
        
        this.systemData.filter(i => i.type === 'Planet').forEach(p => {
             major.push(p.name);
        });
        
        this.systemData.forEach(scanItem);
        
        this.dom.dataList.value = "--- MAJOR SITES & PLANETS ---\n" + major.sort().join("\n") + "\n\n--- MINOR RUINS & DEBRIS ---\n" + minor.sort().join("\n");
    }

    toggleLabels() {
        this.labelsVisible = !this.labelsVisible;
        this.svgGroups.labels.style.display = this.labelsVisible ? '' : 'none';
    }
    
    bindMapListeners() {
        this.svg.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            this.isPanning = true;
            this.panStartRect = this.svg.getBoundingClientRect(); 
            this.startPoint = this.getSvgCoords(e, this.panStartRect);
            this.svg.style.cursor = 'grabbing';
        });

        const stopPan = () => {
            this.isPanning = false; 
            this.svg.style.cursor = 'grab';
            this.panStartRect = null;
            if (this.rafId) {
                cancelAnimationFrame(this.rafId);
                this.rafId = null;
            }
        };

        this.svg.addEventListener('mouseup', stopPan);
        this.svg.addEventListener('mouseleave', stopPan);
        
        this.svg.addEventListener('mousemove', e => {
            if (!this.isPanning) return;
            
            if (this.rafId) return;

            this.rafId = requestAnimationFrame(() => {
                const p = this.getSvgCoords(e, this.panStartRect); 
                this.viewBox.x += (this.startPoint.x - p.x);
                this.viewBox.y += (this.startPoint.y - p.y);
                this.updateViewBox();
                this.rafId = null;
            });
        });

        this.svg.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = this.svg.getBoundingClientRect();
            const m = this.getSvgCoords(e, rect);
            const f = e.deltaY < 0 ? 0.9 : 1.1;
            this.viewBox.x = m.x - (m.x - this.viewBox.x) * f;
            this.viewBox.y = m.y - (m.y - this.viewBox.y) * f;
            this.viewBox.w *= f; this.viewBox.h *= f;
            this.updateViewBox();
        });
    }

    updateViewBox() { this.svg.setAttribute('viewBox', `${this.viewBox.x} ${this.viewBox.y} ${this.viewBox.w} ${this.viewBox.h}`); }
    
    getSvgCoords(e, rect) {
        const r = rect || this.svg.getBoundingClientRect();
        const rx = this.viewBox.w / r.width, ry = this.viewBox.h / r.height;
        return { x: this.viewBox.x + (e.clientX - r.left) * rx, y: this.viewBox.y + (e.clientY - r.top) * ry };
    }
    
    seededRNG(seed) {
        let h = 2166136261 >>> 0;
        for (let i = 0; i < seed.length; i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
        let s = h;
        return () => { s = (Math.imul(48271, s) % 2147483647); return (s & 0x7fffffff) / 2147483647; };
    }

    choice(arr) { return arr[Math.floor(this.rng() * arr.length)]; }

    collides(x, y, r) {
        const newRadiusWithBuffer = r + 15;
        const candidates = this.spatialHash.getCandidates(x, y);
        
        for (let i = 0; i < candidates.length; i++) {
            const o = candidates[i];
            const dx = x - o.x;
            const dy = y - o.y;
            const distSq = (dx * dx) + (dy * dy);
            const radii = (newRadiusWithBuffer + o.r);
            const radiiSq = radii * radii;
            if (distSq < radiiSq) return true;
        }
        return false;
    }
    
    reserve(x, y, r) { 
        const obj = { x, y, r };
        this.placedObjects.push(obj); 
        this.spatialHash.add(x, y, r, obj); 
    }

    findOpenSpot(cx, cy, radius, minRange, rangeVariance, maxTries = 20) {
        let tries = 0, x, y;
        do {
            const angle = this.rng() * Math.PI * 2;
            const dist = minRange + this.rng() * rangeVariance;
            x = cx + Math.cos(angle) * dist;
            y = cy + Math.sin(angle) * dist;
            tries++;
        } while (this.collides(x, y, radius) && tries < maxTries);
        if (tries < maxTries) { this.reserve(x, y, radius); return { x, y }; }
        return null;
    }

    genDesignation() {
        const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
        return (Math.floor(this.rng() * 9000) + 1000) + this.choice(letters);
    }
    
    genRuinName(prefixList, factionList = null) {
        const factions = factionList || CONFIG.ruinFactions;
        const faction = this.choice(factions);
        const prefix = this.choice(prefixList);
        const designation = this.genDesignation();
        return `${faction} ${prefix}-${designation}`;
    }

    createEl(tag, attributes) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const key in attributes) el.setAttribute(key, attributes[key]);
        return el;
    }

    drawText(x, y, txt, small = false) {
        const fontSize = small ? 9 : 11;
        const fill = small ? '#aab8c0' : '#cfeff7';
        // Optimization: Push text string to buffer
        this.svgBuffers['labels'].push(`<text x="${x}" y="${y}" font-size="${fontSize}" fill="${fill}">${txt}</text>`);
    }

    drawOrbit(radius) {
        this.svgBuffers['orbits'].push(`<circle r="${radius}" fill="none" stroke="rgba(255,255,250,0.05)" />`);
    }

    // OPTIMIZATION: Updated drawShape to use String Buffering
    drawShape(type, x, y, r, attrs = {}, groupName) {
        let shapeStr = '';
        let shapeAttrs = { ...attrs };
        
        if (type === 'circle') {
            shapeStr = `<circle cx="${x}" cy="${y}" r="${r}"`;
        } else if (type === 'rect') {
            shapeStr = `<rect x="${x - r/2}" y="${y - r/2}" width="${r}" height="${r}"`;
        } else if (type === 'polygon' || type === 'triangle' || type === 'diamond') {
            const points = this.getPolyPoints(type, x, y, r, shapeAttrs.sides);
            shapeStr = `<polygon points="${points}"`;
        }
        
        // Add attributes
        delete shapeAttrs.sides; // cleanup
        for (const [key, value] of Object.entries(shapeAttrs)) {
            shapeStr += ` ${key}="${value}"`;
        }
        shapeStr += ' />';
        
        this.svgBuffers[groupName].push(shapeStr);
    }

    getPolyPoints(type, x, y, r, sides) {
        if (type === 'triangle') return `${x},${y - r} ${x + r * 0.866},${y + r * 0.5} ${x - r * 0.866},${y + r * 0.5}`;
        if (type === 'diamond') return `${x},${y - r} ${x + r},${y} ${x},${y + r} ${x - r},${y}`;
        let pts = [];
        const numSides = sides || 6;
        const angleOffset = (numSides === 6) ? - (Math.PI / numSides) : 0; 
        for (let i = 0; i < numSides; i++) {
            const ang = (Math.PI * 2 * i / numSides) + angleOffset; 
            pts.push((x + r * Math.cos(ang)) + ',' + (y + r * Math.sin(ang)));
        }
        return pts.join(' ');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const domElements = {
        svg: document.getElementById('map'),
        infoList: document.getElementById('infoList'),
        dataList: document.getElementById('generatedDataList'),
        seedInput: document.getElementById('seedInput'),
        generateBtn: document.getElementById('generateBtn'),
        randomSeedBtn: document.getElementById('randomSeedBtn'),
        toggleLabelsBtn: document.getElementById('toggleLabelsBtn'),
        infoPanel: document.getElementById('infoPanel'),
        infoToggleBtn: document.getElementById('infoToggleBtn'),
        systemNameLabel: document.getElementById('systemNameLabel'),
        systemInfoText: document.getElementById('systemInfoText'),
        systemType: document.getElementById('systemType')
    };
    const generator = new RuinSystemGenerator(domElements.svg, domElements);
    generator.init();
});
</script>
</body>
</html>
