<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Star System Generator (Optimized)</title>
<style>
  body { margin:0; font-family:'Segoe UI',sans-serif; background:#031018; color:#e6f1ff; display:flex; height:100vh; overflow:hidden }
  .sidebar { width:300px; background:#041924; border-right:2px solid #072839; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; gap:12px; z-index:10; overflow-y:auto; }
  .sidebar h1{font-size:1.3em;margin:0;color:#fff}
  .sidebar label{color:#9fcbdc; margin-top:8px; font-weight:600; font-size:0.9em;}
  .sidebar input, .sidebar select {width:100%;padding:8px;border-radius:6px;border:1px solid #0b3c57;background:#072839;color:#aee1ff; box-sizing:border-box;}
  .buttons{display:flex;flex-direction:column;gap:8px; margin-top:10px;}
  button{padding:8px 12px;border-radius:6px;border:none;background:#f6c435;color:#111;font-weight:700;cursor:pointer}
  button:hover{background:#ffda66}
  .btn-secondary{background:#0b3c57;color:#aee1ff}
  .btn-secondary:hover{background:#0e4a6d}
  #map{flex:1;cursor:grab;background:linear-gradient(180deg,#021018,#031018); will-change:transform;}
  text{font-size:11px;fill:#cfeff7;user-select:none; pointer-events:none;}
  .map-object{cursor:pointer;}
  .map-object.selected{stroke:#f6c435 !important; stroke-width:4 !important;}

  #infoPanel { width:300px; background:#041924; border-left:2px solid #072839; display:flex; flex-direction:column; transition: margin-right 0.3s ease; z-index:10; }
  #infoPanel.hidden { margin-right:-300px; }
  #infoToggleBtn { padding:8px 12px; background:#0b3c57; color:#aee1ff; border:none; cursor:pointer; font-weight:700; }
  #infoToggleBtn:hover { background:#0e4a6d; }
  #infoListContainer { flex:1; overflow-y:auto; padding-top:15px; box-sizing:border-box; }

  #systemDescription { padding:0 15px 15px 15px; border-bottom:1px solid #072839; margin-bottom:10px; }
  #systemDescription h2 { font-size:1.1em; color:#f6c435; margin:0 0 8px 0; }
  #systemDescription p { font-size:0.9em; color:#b8dcec; margin:6px 0; line-height:1.4; }
  .syslabel { color:#f6c435; font-weight:700; }

  #editorPanel { padding:10px 15px 15px 15px; border-bottom:1px solid #072839; background:#062235; display:none; }
  #editorPanel h3 { margin:0 0 8px 0; font-size:1.0em; color:#fff; }
  #editorPanel .row { display:flex; gap:8px; }
  #editorPanel .row > * { flex:1; }
  #editorPanel input, #editorPanel select { width:100%; padding:6px; border-radius:6px; border:1px solid #0b3c57; background:#072839; color:#aee1ff; box-sizing:border-box; }
  #editorPanel small { color:#86a7ad; display:block; margin-top:6px; }
  #editorPanel .editor-actions { display:flex; gap:8px; margin-top:8px; }
  #editorPanel .editor-actions button { flex:1; }

  #infoListContainer h2.directory-title { font-size:1.2em; color:#fff; margin:0 15px 10px 15px; border-bottom:1px solid #072839; padding-bottom:5px; }
  #infoList { list-style:none; padding:0 15px; margin:0; }
  #infoList > li { margin-bottom:8px; }
  .info-header { background:#072839; padding:6px 10px; border-radius:4px; font-size:0.9em; font-weight:600; color:#cfeff7; }
  .info-header.collapsible { cursor:pointer; color:#fff; }
  .info-header.collapsible:hover { background:#0b3c57; }
  .info-header.collapsible::before { content:'+ '; font-weight:bold; color:#f6c435; }
  .info-header.collapsible.expanded::before { content:'- '; }
  .info-sublist { list-style:none; padding:5px 0 0 15px; margin:0; font-size:0.85em; display:none; }
  .info-sublist.visible { display:block; }
  .info-sublist li { position:relative; padding-left:15px; margin-top:4px; color:#b8dcec; }
  .info-sublist li::before { content:'\2514'; position:absolute; left:0; top:-2px; color:#0b3c57; }

  .legend { margin-top:8px; padding:10px; background:#072839; border:1px solid #0b3c57; border-radius:6px; }
  .legend h2 { margin:0 0 6px 0; font-size:0.95em; color:#fff; }
  .legend .legend-item { display:flex; align-items:center; gap:8px; font-size:0.85em; color:#b8dcec; margin:4px 0; }
  .legend svg { flex:0 0 auto; }
</style>
</head>
<body>
  <div class="sidebar">
    <h1>Star System Generator</h1>

    <label for="systemType">System Configuration</label>
    <select id="systemType">
      <option value="single">Single Star (Standard)</option>
      <option value="binary">Binary Star (P-Type Orbits)</option>
      <option value="mega">Mega Star System (Single, Vast)</option>
      <option value="cluster">Cluster System (Two Separate Stars)</option>
      <option value="cluster3">Cluster System (Three Separate Stars)</option>
      <option value="triangulum">Triangulum (Three Stars, Triangle Focus)</option>
    </select>

    <label for="seedInput">Seed</label>
    <input id="seedInput" placeholder="Enter seed (e.g. S12345)" />

    <div class="buttons">
      <button id="generateBtn">Generate System</button>
      <button id="randomSeedBtn">Random Seed</button>
      <button id="toggleLabelsBtn">Toggle Labels</button>
      <button id="editorBtn" class="btn-secondary">Map Editor</button>
      <button id="exportBtn" class="btn-secondary">Export .map</button>
      <button id="importBtn" class="btn-secondary">Import .map</button>
      <input id="importFile" type="file" accept=".map,.json,application/json" style="display:none" />
    </div>

    <small style="color:#86a7ad; margin-bottom:10px;">Drag to pan, scroll to zoom. Editor mode lets you select/drag objects.</small>

    <div class="legend" aria-label="Map legend">
      <h2>Legend</h2>
      <div class="legend-item">
        <svg width="18" height="18" viewBox="0 0 18 18" aria-hidden="true"><circle cx="9" cy="9" r="5" fill="#cfeff7"/></svg>
        Planets &amp; moons (Circle)
      </div>
      <div class="legend-item">
        <svg width="18" height="18" viewBox="0 0 18 18" aria-hidden="true"><rect x="6" y="6" width="6" height="6" fill="#b8dcec"/></svg>
        Depots / nodes (Small square)
      </div>
      <div class="legend-item">
        <svg width="18" height="18" viewBox="0 0 18 18" aria-hidden="true"><rect x="4.5" y="4.5" width="9" height="9" fill="#8a9aab"/></svg>
        Space stations (Medium square)
      </div>
      <div class="legend-item">
        <svg width="18" height="18" viewBox="0 0 18 18" aria-hidden="true"><rect x="3" y="7" width="12" height="4" fill="#ffd08a"/></svg>
        Shipyards / dockyards (Rectangle)
      </div>
      <div class="legend-item">
        <svg width="18" height="18" viewBox="0 0 18 18" aria-hidden="true"><polygon points="9,2.5 15.5,9 9,15.5 2.5,9" fill="#b99fff"/></svg>
        Large space stations (Diamond)
      </div>
      <div class="legend-item">
        <svg width="18" height="18" viewBox="0 0 18 18" aria-hidden="true"><polygon points="9,2.5 14.5,6.5 12.5,14.5 5.5,14.5 3.5,6.5" fill="#cc8888"/></svg>
        Fortresses (Pentagon)
      </div>
      <div class="legend-item">
        <svg width="18" height="18" viewBox="0 0 18 18" aria-hidden="true"><polygon points="9,3 15,14 3,14" fill="none" stroke="#9effde" stroke-width="2"/></svg>
        Stargate (Triangle)
      </div>
    </div>

    <label for="generatedDataList">System Data Log</label>
    <textarea id="generatedDataList" rows="12" style="width:100%;background:#072839;color:#aee1ff;border:1px solid #0b3c57;border-radius:6px;font-size:0.8em; box-sizing:border-box;" readonly placeholder="Generated data..."></textarea>
  </div>

  <svg id="map" viewBox="-1500 -1500 3000 3000" xmlns="http://www.w3.org/2000/svg" aria-label="Star system map"></svg>

  <div id="infoPanel">
    <button id="infoToggleBtn">Toggle Panel</button>
    <div id="infoListContainer">
      <div id="systemDescription">
        <h2 id="systemNameLabel">Name of system: ...</h2>
        <p><span class="syslabel">Type of system:</span> <span id="systemTypeLabel">...</span></p>
        <p><span class="syslabel">Agreement:</span> <span id="systemAgreementLabel">...</span></p>
        <p class="syslabel">Description:</p>
        <p id="systemInfoText">Generating system data...</p>
      </div>

      <div id="editorPanel">
        <h3>Map Editor</h3>
        <div class="row">
          <div>
            <label style="display:block; color:#9fcbdc; font-size:0.85em; margin-bottom:4px;">Selected</label>
            <input id="edSelected" readonly placeholder="(none)" />
          </div>
          <div>
            <label style="display:block; color:#9fcbdc; font-size:0.85em; margin-bottom:4px;">Type</label>
            <select id="edType">
              <option value="Planet">Planet</option>
              <option value="Moon">Moon</option>
              <option value="Depot">Depot</option>
              <option value="Space Station">Space Station</option>
              <option value="Shipyard">Shipyard</option>
              <option value="Large Space Station">Large Space Station</option>
              <option value="Fortress">Fortress</option>
              <option value="Stargate">Stargate</option>
            </select>
          </div>
        </div>

        <label style="display:block; color:#9fcbdc; font-size:0.85em; margin:8px 0 4px 0;">Name</label>
        <input id="edName" placeholder="Name..." />

        <div class="row" style="margin-top:8px;">
          <div>
            <label style="display:block; color:#9fcbdc; font-size:0.85em; margin-bottom:4px;">Role (Depots)</label>
            <input id="edRole" placeholder="e.g. Logistics" />
          </div>
          <div>
            <label style="display:block; color:#9fcbdc; font-size:0.85em; margin-bottom:4px;">Coords</label>
            <input id="edXY" readonly placeholder="x,y" />
          </div>
        </div>

        <div class="editor-actions">
          <button id="edSaveBtn">Save</button>
          <button id="edDeleteBtn" class="btn-secondary">Delete</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label style="display:block; color:#9fcbdc; font-size:0.85em; margin-bottom:4px;">Add object</label>
            <select id="edAddType">
              <option value="Depot">Depot</option>
              <option value="Space Station">Space Station</option>
              <option value="Shipyard">Shipyard</option>
              <option value="Large Space Station">Large Space Station</option>
              <option value="Fortress">Fortress</option>
              <option value="Planet">Planet</option>
              <option value="Moon">Moon</option>
              <option value="Stargate">Stargate</option>
            </select>
          </div>
          <div style="display:flex; align-items:flex-end;">
            <button id="edPlaceBtn" class="btn-secondary" style="width:100%;">Place</button>
          </div>
        </div>

        <small id="edHint">Tip: Click an object to select, drag to move. Use Place then click empty space.</small>
      </div>

      <h2 class="directory-title">System Directory</h2>
      <ul id="infoList"></ul>
    </div>
  </div>

<script>
'use strict';

const CONFIG = {
  modes: {
    single: { kind: 'single', viewBox: { x: -2000, y: -2000, w: 4000, h: 4000 }, countMultiplier: 1.0, stationMultiplier: 1.0, depotMultiplier: 1.0, starCount: 1, maxRangeMultiplier: 1.0, orbitMultiplier: 1.0, instabilityRadius: 200, spatialCellSize: 160 },
    binary: { kind: 'binary', viewBox: { x: -3500, y: -3500, w: 7000, h: 7000 }, countMultiplier: 1.8, stationMultiplier: 1.1, depotMultiplier: 1.1, starCount: 2, maxRangeMultiplier: 1.9, orbitMultiplier: 1.4, instabilityRadius: 600, spatialCellSize: 175, binarySeparation: 140 },
    mega: { kind: 'single', viewBox: { x: -22000, y: -22000, w: 44000, h: 44000 }, countMultiplier: 3.2, stationMultiplier: 2.1, depotMultiplier: 1.5, starCount: 1, maxRangeMultiplier: 5.0, orbitMultiplier: 3.0, instabilityRadius: 260, spatialCellSize: 260 },
    cluster: { kind: 'cluster', viewBox: { x: -30000, y: -20000, w: 60000, h: 40000 }, countMultiplier: 2.7, stationMultiplier: 1.9, depotMultiplier: 1.4, starCount: 2, maxRangeMultiplier: 4.5, orbitMultiplier: 2.6, instabilityRadius: 240, spatialCellSize: 250, clusterSeparation: 24000 },
    cluster3: { kind: 'cluster', viewBox: { x: -48000, y: -22000, w: 96000, h: 44000 }, countMultiplier: 3.0, stationMultiplier: 2.0, depotMultiplier: 1.45, starCount: 3, maxRangeMultiplier: 5.0, orbitMultiplier: 2.8, instabilityRadius: 240, spatialCellSize: 265, clusterSeparation: 24000 },
    triangulum: { kind: 'triangulum', viewBox: { x: -45000, y: -40000, w: 90000, h: 80000 }, countMultiplier: 3.0, stationMultiplier: 2.2, depotMultiplier: 1.6, starCount: 3, maxRangeMultiplier: 5.5, orbitMultiplier: 2.5, instabilityRadius: 240, spatialCellSize: 275, triangleSide: 30000, triangleBuildBias: 0.78 },
  },

  agreements: [
    { title: 'Star System Recovery Agreement', blurb: 'A formal plan to rehabilitate infrastructure and reopen safe corridors under joint oversight.' },
    { title: 'Star System Development Agreement', blurb: 'A staged settlement and investment charter with defined build targets and security obligations.' },
    { title: 'Dawn Accord (Construct Stargates)', blurb: 'Authorises stargate construction and calibration, including guard deployment and traffic rules.' },
    { title: 'Zyith Collection Agreement (Mine Zyith Crystals)', blurb: 'Grants extraction rights to mine Zyith crystals under audited quotas and hazard protocols.' },
    { title: 'Freeport Docking Convention', blurb: 'Sets neutral docking rules and dispute arbitration for independent operators.' },
    { title: 'Escort Contract Framework', blurb: 'Defines standard escort rates, liability, and rules of engagement on long-haul routes.' },
    { title: 'Survey Data Escrow Pact', blurb: 'Requires anomaly data to be deposited with a third party before commercial exploitation.' },
    { title: 'Quarantine and Biohazard Protocol', blurb: 'Imposes inspections and restricted approach corridors around suspect worlds.' },
  ],

  systemNames: [
    'Orionis', 'Pleiades Sector', 'Rift-Alpha', 'Astra-9', 'Nebula-Veridian', 'Erebus-Pass', 'Hyperion-Gate',
    'Koraon-Expanse', 'Vesper-Reach', 'Andromeda-C-3', 'Stygia-Nexus', 'Kepler Drift', 'Altair Verge', 'Procyon Spur',
    'Lumen Divide', 'Cinder Arch', 'Vanta Corridor', 'Heliopax Reach', 'Trappist Fold', 'Gliese Lantern', 'Sagan March'
  ],

  factions: [
    'Celestial Consortium', 'Nova Clan', 'Varkhal Dominion', 'Thalor Ascendancy', 'Eclipse Directorate', 'Aurelion League',
    'Obsidian Synod', 'Heliarch Compact', 'Free Belt Coalition', 'Parallax Institute', 'Lacuna Cartel', 'Kestrel Compact',
    'Sable Court', 'Heliotrope Synod', 'Mirrorglass Combine', 'Riftward Union'
  ],

  factionStyles: {
    'Celestial Consortium': { archetype: 'commercial hegemon', vibe: 'contracts, cartography, and quiet leverage', agenda: 'securing stable corridors and exclusive survey rights' },
    'Nova Clan': { archetype: 'diaspora flotilla', vibe: 'kinship fleets and stubborn independence', agenda: 'protecting migrant routes and finding safe anchorage worlds' },
    'Varkhal Dominion': { archetype: 'militarist autarchy', vibe: 'border bastions and hard doctrine', agenda: 'turning outer lanes into enforceable buffer territory' },
    'Thalor Ascendancy': { archetype: 'post-human technate', vibe: 'uplifts, patents, and strange ethics', agenda: 'harvesting anomalies for propulsion and cognition research' },
    'Eclipse Directorate': { archetype: 'intelligence state', vibe: 'black archives and deniable assets', agenda: 'controlling information flow across gate-linked routes' },
    'Aurelion League': { archetype: 'federal republic', vibe: 'coalitions, ballots, and expedition grants', agenda: 'expanding settlements while keeping pirates at bay' },
    'Obsidian Synod': { archetype: 'secretive post-human cult', vibe: 'sealed monasteries and encrypted rites', agenda: 'cataloguing relics and guarding taboo sites' },
    'Heliarch Compact': { archetype: 'stellar aristocracy', vibe: 'succession politics and private fleets', agenda: 'claiming prestige systems to legitimise contested titles' },
    'Free Belt Coalition': { archetype: 'frontier guild pact', vibe: 'barter networks and mutual defence', agenda: 'keeping independents alive without becoming anyone\'s vassal' },
    'Parallax Institute': { archetype: 'research collective', vibe: 'field labs and dangerous curiosity', agenda: 'publishing discoveries before they can be buried' },
    'Lacuna Cartel': { archetype: 'criminal consortium', vibe: 'smuggling lanes and shadow ports', agenda: 'exploiting patrol gaps for profit and influence' },
    'Kestrel Compact': { archetype: 'mutual-aid pact', vibe: 'repair crews and convoy oaths', agenda: 'securing safe harbour status along long-haul routes' },
    'Sable Court': { archetype: 'oligarchic court', vibe: 'patronage and quiet assassinations', agenda: 'buying legitimacy with strategic holdings' },
    'Heliotrope Synod': { archetype: 'mystic guild', vibe: 'pilgrims and star-liturgy', agenda: 'mapping relic trails and sanctioning pilgrim corridors' },
    'Mirrorglass Combine': { archetype: 'manufacturing bloc', vibe: 'foundries and audited scarcity', agenda: 'locking down hull fabrication rights and supply chains' },
    'Riftward Union': { archetype: 'border wardens', vibe: 'watch posts and clipped comms', agenda: 'containing spillover conflicts and stabilising chokepoints' },
  },

  hook_discovery: [
    'a routine survey mission', 'a miscalculated FTL jump', 'following a fresh cartography lead', 'a long-range sensor ghost',
    'a classified scout probe', 'the last ping of a lost courier', 'a salvage crew chasing a pre-collapse beacon',
    'a diplomatic delegation escaping an ambush', 'a gate mapping exercise that went off-script',
    'a colony ship forced to divert by stellar weather'
  ],
  hook_feature: [
    'a high concentration of rare isotopes', 'unusual gravimetric distortions', 'a stable wormhole-adjacent anomaly',
    'a dense asteroid belt rich in volatiles', 'a uniquely calm heliopause', 'a resonant quantum field',
    'an outer-ring debris cloud that behaves like a swarm', 'magnetar-like pulses that do not match local mass',
    'a silent network of ancient transponders', 'a shock-front that keeps rewriting nav solutions'
  ],
  hook_status: [
    'is a growing trade waypoint', 'is tightly monitored by competing powers', 'is frequented by prospectors and explorers',
    'hosts a quiet research presence', 'serves as a staging ground for long-haul routes', 'is whispered about on closed comms',
    'is a tense buffer zone where patrols play chicken', 'is economically vital despite being politically radioactive',
    'is a logistical linchpin for far-range shipping', 'is the kind of place you do not mention on open comms'
  ],

  story_tone: ['clinical and careful', 'hopeful but wary', 'grimly pragmatic', 'hushed and superstitious', 'opportunistic', 'bureaucratically optimistic'],
  story_pressure: [
    'a pirate flotilla probing the lanes', 'an embargo tightening like a noose', 'a border skirmish that keeps escalating',
    'an outbreak of counterfeit nav keys', 'a salvage rush that turns ugly', 'a string of ships vanishing in the outer dark',
    'a dispute over who owns the survey data', 'a quiet arms build-up near the gate'
  ],
  story_rumor: [
    'a derelict megastructure fragment', 'a machine-cult shrine in a moon cavern', 'a ghost signal that replies to questions',
    'a hidden shipyard paying in untraceable scrip', 'a dead station that still draws power', 'a map that only appears during solar storms',
    'a treaty cache sealed behind a false asteroid', 'a stargate key whose checksum should not exist'
  ],
  story_favor: ['survey rights', 'refuel access', 'escort contracts', 'quiet resupply', 'safe harbour status', 'exclusive docking priority', 'data escrow', 'medical aid'],

  planetTypes: ['Volcanic','Oceanic','Ice','Gas','Crystalline','Jungle','Desert','Artificial','Toxic','Shadow','Radiant','Coral','Storm','Barren','Frozen','Magma','Arid','Ringed World','Forge World','Ecumenopolis','Chrono-Locked'],
  planetColorMap: {
    'Volcanic': '#E74C3C', 'Oceanic': '#3498DB', 'Ice': '#F2F3F4', 'Gas': '#F1C40F', 'Crystalline': '#A569BD',
    'Jungle': '#27AE60', 'Desert': '#D35400', 'Artificial': '#9B59B6', 'Toxic': '#8E44AD', 'Shadow': '#34495E',
    'Radiant': '#FEFDFE', 'Coral': '#FF6B6B', 'Storm': '#7D97A0', 'Barren': '#9E9D9B', 'Frozen': '#B2DFFC',
    'Magma': '#F39C12', 'Arid': '#E67E22', 'Ringed World': '#FAD7A0', 'Forge World': '#E67E22',
    'Ecumenopolis': '#BDC3C7', 'Chrono-Locked': '#FAD7A0', 'default': '#95A5A6'
  },
  planetRoots: ['Koraon','Erebus','Nalara','Zephyra','Tarkon','Virella','Dravon','Solara','Elios','Thalor','Maren','Kythera','Velara','Xenon','Orpheus','Zanros','Vastor','Aelion','Boreas','Caelos','Rylos','Hyperion','Nova','Onyx'],

  depotRoles: [
    { role: 'Logistics', prefixes: ['Logistics Depot', 'Supply Hub', 'Cargo Relay', 'Freight Spur', 'Container Yard'] },
    { role: 'Military', prefixes: ['Arsenal Depot', 'Defense Cache', 'Garrison Node', 'Ordnance Silo', 'Munitions Hold'] },
    { role: 'Transit', prefixes: ['Transit Node', 'Jump Relay', 'Nav Junction', 'Lane Beacon', 'Traffic Buoy'] },
    { role: 'Industrial', prefixes: ['Refinery Store', 'Fabrication Hold', 'Mining Silo', 'Parts Stockpile', 'Refit Cache'] },
    { role: 'Comms', prefixes: ['Comms Repeater', 'Sensor Buoy', 'Telemetry Node', 'Survey Relay', 'Signal Mast'] },
    { role: 'Emergency', prefixes: ['Emergency Vault', 'Rescue Locker', 'Lifeline Cache', 'Distress Buoy', 'Safehouse Pod'] },
  ],

  // Colours
  depotColor: ['#b8dcec', '#a9d0db'],
  stationColor: ['#8a9aab'],
  shipyardColor: ['#ffd08a'],
  largeStationColor: ['#b99fff'],
  fortressColor: ['#cc8888', '#88cc88'],

  stargateColor: '#9effde',
  radiationColor: 'rgba(255, 100, 50, 0.15)',
  instabilityColor: 'rgba(255, 50, 50, 0.1)',

  // Naming
  stationPrefixes: ['Orbital Station', 'Trade Post', 'Habitat Ring', 'Survey Platform', 'Deep-Space Relay', 'Traffic Control', 'Science Annex'],
  largeStationPrefixes: ['Grand Hub', 'Anchor Spire', 'Sector Nexus', 'Ring Citadel', 'Titan Platform', 'Gate Bastion'],
  fortressPrefixes: ['System Fortress', 'Citadel', 'Aegis Bastion', 'Watchtower Prime', 'Defense Platform'],
  shipyardPrefixes: ['Shipyard', 'Dockyard', 'Orbital Drydock', 'Slipway', 'Assembly Pier'],

  discoveryYear: (rng) => Math.floor(rng() * 200) + 2250,

  // Generation knobs
  planet: { count: (rng) => 7 + Math.floor(rng() * 5), minOrbit: 350, orbitStep: 220, orbitVariance: 60, minRadius: 25, radiusVariance: 10, clusterRadius: 40 },
  moon: { count: (rng) => Math.floor(rng() * 4), minDist: 55, distVariance: 70, minRadius: 7, radiusVariance: 6, labelOffset: 3, angleJitterRad: 0.2 },
  planetaryDepot: { count: (rng) => 2 + Math.floor(rng() * 4), minDist: 70, distVariance: 90, size: 8 },
  scatteredDepot: { count: (rng) => 40 + Math.floor(rng() * 25), size: 7, minRange: 650, maxRange: 3600 },
  station: { count: (rng) => 8 + Math.floor(rng() * 6), size: 16, planetBias: 0.7, nearPlanetMinDist: 95, nearPlanetDistVariance: 220, minRange: 900, maxRange: 3200 },
  shipyard: { count: (rng) => 3 + Math.floor(rng() * 4), w: 22, h: 12, planetBias: 0.85, nearPlanetMinDist: 140, nearPlanetDistVariance: 260, minRange: 1000, maxRange: 3400 },
  largeStation: { count: (rng) => 3 + Math.floor(rng() * 3), size: 22, planetBias: 0.85, nearPlanetMinDist: 120, nearPlanetDistVariance: 260, minRange: 1100, maxRange: 3400 },
  fortress: { count: (rng) => 2 + Math.floor(rng() * 2), size: 26, nearPlanetMinDist: 140, nearPlanetDistVariance: 280, depotEscortCount: (rng) => 10 + Math.floor(rng() * 9), depotEscortMinDist: 75, depotEscortDistVariance: 80, depotEscortSize: 8 },
  stargate: { size: 40, minRange: 2200, maxRange: 3800, guardCount: 3, guardSize: 20, guardMinDist: 95, guardDistVariance: 70 },
};

class SpatialHash {
  constructor(cellSize) { this.cellSize = cellSize; this.grid = new Map(); }
  getKey(x, y) { return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`; }
  add(x, y, r) {
    const key = this.getKey(x, y);
    let bucket = this.grid.get(key);
    if (!bucket) { bucket = []; this.grid.set(key, bucket); }
    bucket.push({ x, y, r });
  }
  getCandidates(x, y) {
    const candidates = [];
    const cx = Math.floor(x / this.cellSize);
    const cy = Math.floor(y / this.cellSize);
    for (let i = -1; i <= 1; i++) {
      for (let j = -1; j <= 1; j++) {
        const key = `${cx + i},${cy + j}`;
        const bucket = this.grid.get(key);
        if (bucket) for (let k = 0; k < bucket.length; k++) candidates.push(bucket[k]);
      }
    }
    return candidates;
  }
  clear() { this.grid.clear(); }
}

class StarSystemGenerator {
  constructor(svgElement, domElements) {
    this.svg = svgElement;
    this.dom = domElements;

    this.rng = () => 0;
    this.spatialHash = new SpatialHash(160);
    this.placedObjects = [];

    this.systemData = [];
    this.objectById = new Map();
    this.nextId = 1;

    this.viewBox = { x: -2000, y: -2000, w: 4000, h: 4000 };
    this.isPanning = false;
    this.startPoint = { x: 0, y: 0 };
    this.panStartRect = null;
    this.rafId = null;

    this.labelsVisible = true;
    this.systemName = '...';
    this.systemTypeText = '...';
    this.systemAgreement = '...';

    this.currentMode = 'single';
    this.modeConfig = CONFIG.modes.single;
    this.seed = '';

    this.starCenters = [{ x: 0, y: 0 }];
    this.triangle = null;

    // Editor state
    this.editorEnabled = false;
    this.selectedId = null;
    this.draggingId = null;
    this.dragStart = null;
    this.dragStartObj = null;
    this.placingType = null;

    this.svgBuffers = { radiation: [], orbits: [], planets: [], stations: [], depots: [], labels: [] };
    this.svgGroups = {
      radiation: this.createEl('g', { id: 'radiationGroup' }),
      orbits: this.createEl('g', { id: 'orbitsGroup' }),
      planets: this.createEl('g', { id: 'planetsGroup' }),
      stations: this.createEl('g', { id: 'stationsGroup' }),
      depots: this.createEl('g', { id: 'depotsGroup' }),
      labels: this.createEl('g', { id: 'labelsGroup' }),
    };
    Object.values(this.svgGroups).forEach(g => this.svg.appendChild(g));
  }

  init() {
    this.bindUIListeners();
    this.bindMapListeners();
    this.dom.seedInput.value = 'S' + Math.floor(Math.random() * 900000 + 100000);
    this.generate();
  }

  // ---------- UI ----------

  bindUIListeners() {
    this.dom.generateBtn.addEventListener('click', () => this.generate());
    this.dom.randomSeedBtn.addEventListener('click', () => {
      this.dom.seedInput.value = 'S' + Math.floor(Math.random() * 900000 + 100000);
      this.generate();
    });
    this.dom.toggleLabelsBtn.addEventListener('click', () => this.toggleLabels());
    this.dom.infoToggleBtn.addEventListener('click', () => this.dom.infoPanel.classList.toggle('hidden'));

    this.dom.editorBtn.addEventListener('click', () => this.toggleEditor());
    this.dom.exportBtn.addEventListener('click', () => this.exportMapFile('map'));
    this.dom.importBtn.addEventListener('click', () => this.dom.importFile.click());
    this.dom.importFile.addEventListener('change', (e) => this.handleImportFile(e));

    // Editor controls
    this.dom.edSaveBtn.addEventListener('click', () => this.applyEditorChanges());
    this.dom.edDeleteBtn.addEventListener('click', () => this.deleteSelected());
    this.dom.edPlaceBtn.addEventListener('click', () => {
      this.placingType = this.dom.edAddType.value;
      this.dom.edHint.textContent = 'Placing: click empty space to add. Press Map Editor again to cancel.';
      this.svg.style.cursor = 'crosshair';
    });
  }

  toggleEditor() {
    this.editorEnabled = !this.editorEnabled;
    this.dom.editorPanel.style.display = this.editorEnabled ? 'block' : 'none';
    this.dom.editorBtn.textContent = this.editorEnabled ? 'Exit Editor' : 'Map Editor';

    if (!this.editorEnabled) {
      this.placingType = null;
      this.svg.style.cursor = 'grab';
      this.clearSelection();
      this.dom.edHint.textContent = 'Tip: Click an object to select, drag to move. Use Place then click empty space.';
    } else {
      this.dom.edHint.textContent = 'Tip: Click an object to select, drag to move. Use Place then click empty space.';
    }

    this.attachObjectEvents();
  }

  // ---------- Core generation ----------

  generate() {
    this.clear();

    this.seed = this.dom.seedInput.value || 'default';
    this.rng = this.seededRNG(this.seed);

    const modeKey = (this.dom.systemType && this.dom.systemType.value) ? this.dom.systemType.value : 'single';
    this.currentMode = modeKey;
    this.modeConfig = CONFIG.modes[modeKey] || CONFIG.modes.single;

    this.spatialHash = new SpatialHash(this.modeConfig.spatialCellSize || 180);

    this.viewBox = { ...this.modeConfig.viewBox };
    this.updateViewBox();

    this.generateStars(this.modeConfig);

    const mult = this.modeConfig.countMultiplier;
    const stationMult = mult * (this.modeConfig.stationMultiplier || 1.0);
    const depotMult = mult * (this.modeConfig.depotMultiplier || 1.0);
    const rangeMult = this.modeConfig.maxRangeMultiplier;

    const planetClusters = this.generatePlanets(this.modeConfig);
    this.generateMoons(planetClusters, mult);
    this.generatePlanetaryDepots(planetClusters, depotMult);

    this.generateStations(planetClusters, stationMult, rangeMult);
    this.generateShipyards(planetClusters, stationMult, rangeMult);
    this.generateLargeStations(planetClusters, stationMult, rangeMult);
    this.generateFortresses(planetClusters, stationMult, rangeMult);

    this.generateStargate(rangeMult);
    this.generateScatteredDepots(depotMult, rangeMult);

    this.generateSystemDescription(this.modeConfig);

    this.renderBuffers();
    this.rebuildIdIndex();
    this.populateInfoPanel();
    this.populateDataList();

    this.attachObjectEvents();
  }

  clear() {
    Object.values(this.svgGroups).forEach(group => (group.innerHTML = ''));
    Object.keys(this.svgBuffers).forEach(k => (this.svgBuffers[k] = []));

    this.spatialHash.clear();
    this.placedObjects = [];

    this.systemData = [];
    this.objectById.clear();
    this.nextId = 1;

    this.dom.infoList.innerHTML = '';
    this.dom.dataList.value = '';

    this.systemName = '...';
    this.systemTypeText = '...';
    this.systemAgreement = '...';

    this.dom.systemNameLabel.textContent = 'Name of system: ...';
    this.dom.systemTypeLabel.textContent = '...';
    this.dom.systemAgreementLabel.textContent = '...';
    this.dom.systemInfoText.textContent = 'Generating system data...';

    this.starCenters = [{ x: 0, y: 0 }];
    this.triangle = null;

    this.clearSelection();
  }

  renderBuffers() {
    this.svgGroups.radiation.innerHTML = this.svgBuffers.radiation.join('');
    this.svgGroups.orbits.innerHTML = this.svgBuffers.orbits.join('');
    this.svgGroups.planets.innerHTML = this.svgBuffers.planets.join('');
    this.svgGroups.stations.innerHTML = this.svgBuffers.stations.join('');
    this.svgGroups.depots.innerHTML = this.svgBuffers.depots.join('');
    this.svgGroups.labels.innerHTML = this.svgBuffers.labels.join('');
  }

  // ---------- Object model helpers ----------

  newId() { return String(this.nextId++); }

  rebuildIdIndex() {
    this.objectById.clear();
    let maxId = 0;

    const walk = (node) => {
      if (!node || typeof node !== 'object') return;
      if (node.id) {
        this.objectById.set(String(node.id), node);
        const n = parseInt(node.id, 10);
        if (!Number.isNaN(n)) maxId = Math.max(maxId, n);
      }
      if (Array.isArray(node.structures)) node.structures.forEach(walk);
    };

    this.systemData.forEach(walk);
    this.nextId = Math.max(this.nextId, maxId + 1);
  }

  // ---------- Stars & geometry ----------

  randomPointInTriangle(A, B, C) {
    const r1 = Math.sqrt(this.rng());
    const r2 = this.rng();
    const a = 1 - r1;
    const b = r1 * (1 - r2);
    const c = r1 * r2;
    return { x: a * A.x + b * B.x + c * C.x, y: a * A.y + b * B.y + c * C.y };
  }

  findOpenSpotInTriangle(tri, radius, maxTries = 60) {
    let tries = 0;
    while (tries < maxTries) {
      const p = this.randomPointInTriangle(tri.A, tri.B, tri.C);
      if (!this.collides(p.x, p.y, radius)) {
        this.reserve(p.x, p.y, radius);
        return { x: p.x, y: p.y };
      }
      tries++;
    }
    return null;
  }

  generateStars(modeConfig) {
    const starRadius = 40;
    const instabilityRadius = modeConfig.instabilityRadius;
    const kind = modeConfig.kind || 'single';
    this.triangle = null;

    if (kind === 'single') {
      this.starCenters = [{ x: 0, y: 0 }];
      this.drawShape('circle', 0, 0, starRadius, { fill: '#fff29f', stroke: '#ffaa00', 'stroke-width': 2 }, 'orbits', null, null);
      this.drawShape('circle', 0, 0, instabilityRadius, { fill: CONFIG.radiationColor, stroke: 'none' }, 'radiation', null, null);
      this.reserve(0, 0, instabilityRadius);
      return;
    }

    if (kind === 'binary') {
      this.starCenters = [{ x: 0, y: 0 }];
      const separation = modeConfig.binarySeparation || 140;
      this.drawShape('circle', -separation, 0, starRadius, { fill: '#ffdf9f', stroke: '#ff8800', 'stroke-width': 2 }, 'orbits', null, null);
      this.drawShape('circle', separation, 0, starRadius * 0.9, { fill: '#9fefff', stroke: '#00ccff', 'stroke-width': 2 }, 'orbits', null, null);
      this.drawShape('circle', 0, 0, instabilityRadius, { fill: CONFIG.instabilityColor, stroke: '#ff4444', 'stroke-width': 2, 'stroke-dasharray': '10 10', 'fill-opacity': 0.1 }, 'radiation', null, null);
      this.reserve(0, 0, instabilityRadius);
      return;
    }

    if (kind === 'cluster') {
      const sep = modeConfig.clusterSeparation || 24000;
      const starCount = modeConfig.starCount || 2;
      if (starCount === 2) this.starCenters = [{ x: -sep / 2, y: 0 }, { x: sep / 2, y: 0 }];
      else this.starCenters = [{ x: -sep, y: 0 }, { x: 0, y: 0 }, { x: sep, y: 0 }];

      for (let i = 0; i < this.starCenters.length; i++) {
        const s = this.starCenters[i];
        const fill = (i % 2 === 0) ? '#ffdf9f' : '#9fefff';
        const stroke = (i % 2 === 0) ? '#ff8800' : '#00ccff';
        this.drawShape('circle', s.x, s.y, starRadius, { fill, stroke, 'stroke-width': 2 }, 'orbits', null, null);
        this.drawShape('circle', s.x, s.y, instabilityRadius, { fill: CONFIG.radiationColor, stroke: 'none' }, 'radiation', null, null);
        this.reserve(s.x, s.y, instabilityRadius);
      }
      return;
    }

    if (kind === 'triangulum') {
      const side = modeConfig.triangleSide || 30000;
      const h = side * Math.sqrt(3) / 2;
      const A = { x: -side / 2, y: h / 3 };
      const B = { x: side / 2, y: h / 3 };
      const C = { x: 0, y: -2 * h / 3 };
      this.triangle = { A, B, C };
      this.starCenters = [A, B, C];

      for (let i = 0; i < this.starCenters.length; i++) {
        const s = this.starCenters[i];
        const fill = (i === 2) ? '#fff29f' : (i === 0 ? '#ffdf9f' : '#9fefff');
        const stroke = (i === 2) ? '#ffaa00' : (i === 0 ? '#ff8800' : '#00ccff');
        this.drawShape('circle', s.x, s.y, starRadius, { fill, stroke, 'stroke-width': 2 }, 'orbits', null, null);
        this.drawShape('circle', s.x, s.y, instabilityRadius, { fill: CONFIG.radiationColor, stroke: 'none' }, 'radiation', null, null);
        this.reserve(s.x, s.y, instabilityRadius);
      }

      this.svgBuffers.orbits.push(`<polygon points="${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y}" fill="none" stroke="rgba(246,196,53,0.08)" stroke-width="3" />`);
    }
  }

  // ---------- Planets ----------

  generatePlanets(modeConfig) {
    const C = CONFIG.planet;
    const kind = modeConfig.kind || 'single';
    const orbitMult = modeConfig.orbitMultiplier || 1.0;

    const totalPlanets = Math.max(1, Math.floor(C.count(this.rng) * modeConfig.countMultiplier));
    const planetClusters = [];
    const baseOrbit = Math.max(C.minOrbit, modeConfig.instabilityRadius + 160);

    const buildOrbits = (n) => {
      const orbits = new Array(n);
      const step = C.orbitStep * orbitMult;
      const varAmt = C.orbitVariance * orbitMult;
      for (let i = 0; i < n; i++) {
        const jitter = (this.rng() * 2 - 1) * varAmt;
        orbits[i] = baseOrbit + i * step + jitter;
      }
      for (let i = orbits.length - 1; i > 0; i--) {
        const j = Math.floor(this.rng() * (i + 1));
        const t = orbits[i];
        orbits[i] = orbits[j];
        orbits[j] = t;
      }
      return orbits;
    };

    const placePlanet = (star, orbit) => {
      const type = this.choice(CONFIG.planetTypes);
      const root = this.choice(CONFIG.planetRoots);
      const baseName = `${root}-${(Math.floor(this.rng() * 900) + 100)}`;

      this.drawOrbit(orbit, star.x, star.y);

      const reserveR = C.clusterRadius;
      let px = 0;
      let py = 0;
      let tries = 0;
      while (tries < 20) {
        const angle = this.rng() * Math.PI * 2;
        px = star.x + Math.cos(angle) * orbit;
        py = star.y + Math.sin(angle) * orbit;
        if (!this.collides(px, py, reserveR)) break;
        tries++;
      }
      if (this.collides(px, py, reserveR)) return;

      this.reserve(px, py, reserveR);

      const radius = C.minRadius + this.rng() * C.radiusVariance;
      const cmap = CONFIG.planetColorMap || { default: '#95A5A6' };
      const color = (cmap[type] || cmap.default);

      const id = this.newId();
      const planetName = `${baseName} (${type})`;
      const planetData = { id, name: planetName, type: 'Planet', x: px, y: py, role: '', structures: [] };
      this.systemData.push(planetData);
      planetClusters.push({ x: px, y: py, name: baseName, data: planetData, radius });

      this.drawShape('circle', px, py, radius, { fill: color }, 'planets', id, { renderKind: 'circle', r: radius });
      this.drawText(px + radius + 5, py + 5, planetName, false, id);
    };

    if (kind === 'cluster' || kind === 'triangulum') {
      const stars = (this.starCenters && this.starCenters.length) ? this.starCenters : [{ x: 0, y: 0 }];
      const per = Math.floor(totalPlanets / stars.length);
      let remainder = totalPlanets - (per * stars.length);
      for (let si = 0; si < stars.length; si++) {
        const count = per + (remainder > 0 ? 1 : 0);
        if (remainder > 0) remainder--;
        const orbits = buildOrbits(count);
        for (let i = 0; i < orbits.length; i++) placePlanet(stars[si], orbits[i]);
      }
      return planetClusters;
    }

    const star = { x: 0, y: 0 };
    const orbits = buildOrbits(totalPlanets);
    for (let i = 0; i < orbits.length; i++) placePlanet(star, orbits[i]);
    return planetClusters;
  }

  generateMoons(planetClusters, multiplier) {
    const C = CONFIG.moon;

    planetClusters.forEach(p => {
      const base = C.count(this.rng);
      const numMoons = Math.min(6, Math.floor(base + (this.rng() * (multiplier * 1.25))));
      if (numMoons <= 0) return;

      const baseAngle = this.rng() * Math.PI * 2;
      for (let i = 0; i < numMoons; i++) {
        const r = C.minRadius + this.rng() * C.radiusVariance;
        const evenAngle = baseAngle + (i / Math.max(1, numMoons)) * (Math.PI * 2);
        const jitter = (this.rng() * 2 - 1) * C.angleJitterRad;
        const angle = evenAngle + jitter;
        const dist = (C.minDist + p.radius * 0.2) + this.rng() * C.distVariance;

        let x = p.x + Math.cos(angle) * dist;
        let y = p.y + Math.sin(angle) * dist;

        let tries = 0;
        while (this.collides(x, y, r + 4) && tries < 15) {
          const j = (this.rng() * 2 - 1) * (C.angleJitterRad * 1.5);
          const a2 = evenAngle + j;
          const d2 = (C.minDist + p.radius * 0.2) + this.rng() * C.distVariance;
          x = p.x + Math.cos(a2) * d2;
          y = p.y + Math.sin(a2) * d2;
          tries++;
        }
        if (this.collides(x, y, r + 4)) continue;

        this.reserve(x, y, r + 4);

        const id = this.newId();
        const moonShort = `${p.name}-${String.fromCharCode(97 + i)}`;
        const moonName = `Moon ${moonShort}`;
        const moonData = { id, name: moonName, type: 'Moon', x, y, role: '', structures: [] };
        p.data.structures.push(moonData);

        this.drawShape('circle', x, y, r, { fill: '#cfeff7', 'fill-opacity': 0.75 }, 'planets', id, { renderKind: 'circle', r });
        this.drawText(x + r + 3, y + C.labelOffset, moonName, true, id);
      }
    });
  }

  // ---------- Depots ----------

  generatePlanetaryDepots(planetClusters, multiplier) {
    const C = CONFIG.planetaryDepot;

    planetClusters.forEach(p => {
      const numDepots = Math.floor(C.count(this.rng) * (0.9 + multiplier * 0.35));

      for (let i = 0; i < numDepots; i++) {
        const pos = this.findOpenSpot(p.x, p.y, C.size, C.minDist + p.radius, C.distVariance, 45);
        if (!pos) continue;

        const depotMeta = this.genDepotName();
        const id = this.newId();
        const data = { id, name: depotMeta.name, type: 'Depot', role: depotMeta.role, x: pos.x, y: pos.y, structures: [] };
        p.data.structures.push(data);

        this.drawShape('rect', pos.x, pos.y, C.size, { fill: this.choice(CONFIG.depotColor) }, 'depots', id, { renderKind: 'rect', size: C.size });
        this.drawText(pos.x + C.size + 2, pos.y, depotMeta.name, true, id);
      }
    });
  }

  generateScatteredDepots(multiplier, rangeMult) {
    const C = CONFIG.scatteredDepot;
    const numDepots = Math.floor(C.count(this.rng) * multiplier);
    const maxRange = C.maxRange * rangeMult;

    for (let i = 0; i < numDepots; i++) {
      let pos = null;
      if (this.modeConfig.kind === 'triangulum' && this.triangle && this.rng() < (this.modeConfig.triangleBuildBias || 0.78)) {
        pos = this.findOpenSpotInTriangle(this.triangle, C.size, 70);
      } else {
        pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 55);
      }
      if (!pos) continue;

      const depotMeta = this.genDepotName();
      const id = this.newId();
      const data = { id, name: depotMeta.name, type: 'Depot', role: depotMeta.role, x: pos.x, y: pos.y, structures: [] };
      this.systemData.push(data);

      this.drawShape('rect', pos.x, pos.y, C.size, { fill: this.choice(CONFIG.depotColor), 'fill-opacity': 0.9 }, 'depots', id, { renderKind: 'rect', size: C.size });
      this.drawText(pos.x + C.size + 2, pos.y, depotMeta.name, true, id);
    }
  }

  genSubDepotCluster(cx, cy, parentData, count, minDist, distVariance, size, preferredRole = null) {
    for (let i = 0; i < count; i++) {
      const pos = this.findOpenSpot(cx, cy, size, minDist, distVariance, 45);
      if (!pos) continue;

      const depotMeta = this.genDepotName(preferredRole);
      const id = this.newId();
      const data = { id, name: depotMeta.name, type: 'Depot', role: depotMeta.role, x: pos.x, y: pos.y, structures: [] };
      parentData.structures.push(data);

      this.drawShape('rect', pos.x, pos.y, size, { fill: this.choice(CONFIG.depotColor) }, 'depots', id, { renderKind: 'rect', size });
      this.drawText(pos.x + size + 2, pos.y, depotMeta.name, true, id);
    }
  }

  // ---------- Stations ----------

  generateStations(planetClusters, multiplier, rangeMult) {
    const C = CONFIG.station;
    const count = Math.floor(C.count(this.rng) * multiplier);
    const maxRange = C.maxRange * rangeMult;

    for (let i = 0; i < count; i++) {
      let pos = null;
      let parent = null;

      if (planetClusters.length > 0 && this.rng() < C.planetBias) {
        const p = this.choice(planetClusters);
        parent = p.data;
        pos = this.findOpenSpot(p.x, p.y, C.size, C.nearPlanetMinDist + p.radius, C.nearPlanetDistVariance, 55);
      } else {
        if (this.modeConfig.kind === 'triangulum' && this.triangle && this.rng() < (this.modeConfig.triangleBuildBias || 0.78)) {
          pos = this.findOpenSpotInTriangle(this.triangle, C.size, 70);
        } else {
          pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 55);
        }
      }

      if (!pos) continue;

      const name = this.genName(CONFIG.stationPrefixes);
      const id = this.newId();
      const data = { id, name, type: 'Space Station', role: '', x: pos.x, y: pos.y, structures: [] };

      if (parent) parent.structures.push(data);
      else this.systemData.push(data);

      this.drawShape('rect', pos.x, pos.y, C.size, { fill: this.choice(CONFIG.stationColor), stroke: '#aabbee', 'stroke-width': 2 }, 'stations', id, { renderKind: 'rect', size: C.size });
      this.drawText(pos.x + C.size + 2, pos.y, name, false, id);

      if (this.rng() < 0.45) this.genSubDepotCluster(pos.x, pos.y, data, 2 + Math.floor(this.rng() * 4), 55, 80, 7);
    }
  }

  generateShipyards(planetClusters, multiplier, rangeMult) {
    const C = CONFIG.shipyard;
    const count = Math.floor(C.count(this.rng) * (0.9 + multiplier * 0.25));
    const maxRange = C.maxRange * rangeMult;

    for (let i = 0; i < count; i++) {
      let pos = null;
      let parent = null;

      if (planetClusters.length > 0 && this.rng() < C.planetBias) {
        const p = this.choice(planetClusters);
        parent = p.data;
        pos = this.findOpenSpot(p.x, p.y, Math.max(C.w, C.h), C.nearPlanetMinDist + p.radius, C.nearPlanetDistVariance, 70);
      } else {
        if (this.modeConfig.kind === 'triangulum' && this.triangle && this.rng() < (this.modeConfig.triangleBuildBias || 0.78)) {
          pos = this.findOpenSpotInTriangle(this.triangle, Math.max(C.w, C.h), 70);
        } else {
          pos = this.findOpenSpot(0, 0, Math.max(C.w, C.h), C.minRange, maxRange - C.minRange, 70);
        }
      }

      if (!pos) continue;

      const name = this.genName(CONFIG.shipyardPrefixes);
      const id = this.newId();
      const data = { id, name, type: 'Shipyard', role: '', x: pos.x, y: pos.y, structures: [] };

      if (parent) parent.structures.push(data);
      else this.systemData.push(data);

      this.drawRectWH(pos.x, pos.y, C.w, C.h, { fill: this.choice(CONFIG.shipyardColor), stroke: '#ffe7c2', 'stroke-width': 2 }, 'stations', id, { renderKind: 'rectWH', w: C.w, h: C.h });
      this.drawText(pos.x + Math.max(C.w, C.h) + 2, pos.y, name, false, id);

      if (this.rng() < 0.65) this.genSubDepotCluster(pos.x, pos.y, data, 3 + Math.floor(this.rng() * 4), 65, 100, 7, 'Logistics');
    }
  }

  generateLargeStations(planetClusters, multiplier, rangeMult) {
    const C = CONFIG.largeStation;
    const count = Math.floor(C.count(this.rng) * multiplier);
    const maxRange = C.maxRange * rangeMult;

    for (let i = 0; i < count; i++) {
      let pos = null;
      let parent = null;

      if (planetClusters.length > 0 && this.rng() < C.planetBias) {
        const p = this.choice(planetClusters);
        parent = p.data;
        pos = this.findOpenSpot(p.x, p.y, C.size, C.nearPlanetMinDist + p.radius, C.nearPlanetDistVariance, 70);
      } else {
        if (this.modeConfig.kind === 'triangulum' && this.triangle && this.rng() < (this.modeConfig.triangleBuildBias || 0.78)) {
          pos = this.findOpenSpotInTriangle(this.triangle, C.size, 70);
        } else {
          pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 70);
        }
      }

      if (!pos) continue;

      const name = this.genName(CONFIG.largeStationPrefixes);
      const id = this.newId();
      const data = { id, name, type: 'Large Space Station', role: '', x: pos.x, y: pos.y, structures: [] };

      if (parent) parent.structures.push(data);
      else this.systemData.push(data);

      this.drawShape('diamond', pos.x, pos.y, C.size, { fill: this.choice(CONFIG.largeStationColor), stroke: '#d7c7ff', 'stroke-width': 2 }, 'stations', id, { renderKind: 'diamond', size: C.size });
      this.drawText(pos.x + C.size + 2, pos.y, name, false, id);

      this.genSubDepotCluster(pos.x, pos.y, data, 3 + Math.floor(this.rng() * 5), 70, 110, 7);
    }
  }

  generateFortresses(planetClusters, multiplier, rangeMult) {
    const C = CONFIG.fortress;
    const count = Math.floor(C.count(this.rng) * multiplier);

    for (let i = 0; i < count; i++) {
      if (planetClusters.length === 0) break;
      const p = this.choice(planetClusters);
      const pos = this.findOpenSpot(p.x, p.y, C.size, C.nearPlanetMinDist + p.radius, C.nearPlanetDistVariance, 85);
      if (!pos) continue;

      const name = this.genName(CONFIG.fortressPrefixes);
      const color = this.choice(CONFIG.fortressColor);
      const id = this.newId();
      const data = { id, name, type: 'Fortress', role: '', x: pos.x, y: pos.y, structures: [] };
      p.data.structures.push(data);

      this.drawShape('polygon', pos.x, pos.y, C.size, { fill: color, stroke: '#ffaaaa', 'stroke-width': 3, sides: 5 }, 'stations', id, { renderKind: 'polygon', size: C.size, sides: 5 });
      this.drawText(pos.x + C.size + 2, pos.y, name, false, id);

      this.genSubDepotCluster(pos.x, pos.y, data, C.depotEscortCount(this.rng), C.depotEscortMinDist, C.depotEscortDistVariance, C.depotEscortSize, 'Military');
    }
  }

  generateStargate(rangeMult) {
    const C = CONFIG.stargate;
    const maxRange = C.maxRange * rangeMult;

    let pos = null;
    if (this.modeConfig.kind === 'triangulum' && this.triangle) {
      pos = this.findOpenSpotInTriangle(this.triangle, C.size, 120);
      if (!pos) pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 90);
    } else {
      pos = this.findOpenSpot(0, 0, C.size, C.minRange, maxRange - C.minRange, 90);
    }
    if (!pos) return;

    const id = this.newId();
    const sgName = `${this.systemName} Stargate`;
    const sgData = { id, name: sgName, type: 'Stargate', role: '', x: pos.x, y: pos.y, structures: [] };
    this.systemData.push(sgData);

    this.drawShape('triangle', pos.x, pos.y, C.size, { fill: 'none', stroke: CONFIG.stargateColor, 'stroke-width': 3 }, 'stations', id, { renderKind: 'triangle', size: C.size });
    this.drawText(pos.x + C.size + 2, pos.y, sgName, false, id);

    for (let i = 0; i < C.guardCount; i++) {
      const gPos = this.findOpenSpot(pos.x, pos.y, C.guardSize, C.guardMinDist, C.guardDistVariance, 80);
      if (!gPos) continue;
      const guardName = this.genName(CONFIG.largeStationPrefixes) + ' (Gate Guard)';
      const gid = this.newId();
      const gData = { id: gid, name: guardName, type: 'Large Space Station', role: '', x: gPos.x, y: gPos.y, structures: [] };
      sgData.structures.push(gData);

      this.drawShape('diamond', gPos.x, gPos.y, C.guardSize, { fill: this.choice(CONFIG.largeStationColor), stroke: '#d7c7ff', 'stroke-width': 2 }, 'stations', gid, { renderKind: 'diamond', size: C.guardSize });
      this.drawText(gPos.x + C.guardSize + 2, gPos.y, guardName, false, gid);

      if (this.rng() < 0.8) this.genSubDepotCluster(gPos.x, gPos.y, gData, 3 + Math.floor(this.rng() * 4), 65, 95, 7, this.rng() < 0.55 ? 'Transit' : 'Military');
    }
  }

  // ---------- Description ----------

  chooseAgreement(modeConfig) {
    const dawn = CONFIG.agreements.find(a => a.title.indexOf('Dawn Accord') === 0);
    const recovery = CONFIG.agreements.find(a => a.title.indexOf('Star System Recovery Agreement') === 0);
    if (modeConfig.kind === 'triangulum' && dawn && this.rng() < 0.55) return dawn;
    if (this.currentMode === 'mega' && recovery && this.rng() < 0.35) return recovery;
    return this.choice(CONFIG.agreements);
  }

  generateSystemDescription(modeConfig) {
    const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
    const systemDesignation = (Math.floor(this.rng() * 90) + 10) + '-' + this.choice(letters);
    this.systemName = this.choice(CONFIG.systemNames) + ' ' + systemDesignation;

    let type = 'Star System';
    if (modeConfig.kind === 'binary') type = 'Binary P-Type System';
    else if (modeConfig.kind === 'cluster') type = (modeConfig.starCount === 3) ? 'Triple Cluster System' : 'Cluster System';
    else if (modeConfig.kind === 'triangulum') type = 'Triangulum System';
    else if (this.currentMode === 'mega') type = 'Mega Star System';

    this.systemTypeText = type;

    const year = CONFIG.discoveryYear(this.rng);
    const factionName = this.choice(CONFIG.factions);
    const factionMeta = CONFIG.factionStyles[factionName] || { archetype: 'unknown polity', vibe: 'low-profile operators', agenda: 'keeping the lanes quiet' };

    const discovery = this.choice(CONFIG.hook_discovery);
    const feature = this.choice(CONFIG.hook_feature);
    const status = this.choice(CONFIG.hook_status);

    const tone = this.choice(CONFIG.story_tone);
    const pressure = this.choice(CONFIG.story_pressure);
    const rumor = this.choice(CONFIG.story_rumor);
    const favor = this.choice(CONFIG.story_favor);

    const agreement = this.chooseAgreement(modeConfig);
    this.systemAgreement = agreement.title;

    const extra = (this.currentMode === 'mega')
      ? 'Distances are vast, patrol gaps are common, and the outer dark can feel like its own country.'
      : (modeConfig.kind === 'cluster')
        ? 'Multiple suns mean multiple economies, and the shipping lanes between them are where most deals get made.'
        : (modeConfig.kind === 'triangulum')
          ? 'Triangulum traffic tends to funnel through the interior, where jurisdictions overlap and rules get negotiated in real time.'
          : '';

    const description = [
      `The ${this.systemName} is a ${type}. Charted in ${year} by the ${factionName} during ${discovery}, it is notable for ${feature}.`,
      `The ${factionMeta.archetype} is known for ${factionMeta.vibe}, and their stated aim here is ${factionMeta.agenda}.`,
      `Locals describe the situation as ${tone}: it ${status}, but remains under pressure from ${pressure}.`,
      `A persistent rumour mentions ${rumor}, and captains whisper that the quickest way to get clearance is trading in ${favor}.`,
      `Agreement note: ${agreement.blurb}`,
      extra
    ].filter(Boolean).join(' ');

    this.dom.systemNameLabel.textContent = `Name of system: ${this.systemName}`;
    this.dom.systemTypeLabel.textContent = this.systemTypeText;
    this.dom.systemAgreementLabel.textContent = this.systemAgreement;
    this.dom.systemInfoText.textContent = description;
  }

  // ---------- Directory panel ----------

  populateInfoPanel() {
    const typeOrder = ['Stargate', 'Planet', 'Moon', 'Fortress', 'Large Space Station', 'Shipyard', 'Space Station', 'Depot'];

    const sortItems = (arr) => arr.slice().sort((a, b) => {
      let ai = typeOrder.indexOf(a.type);
      let bi = typeOrder.indexOf(b.type);
      if (ai === -1) ai = 99;
      if (bi === -1) bi = 99;
      if (ai !== bi) return ai - bi;
      return (a.name || '').localeCompare(b.name || '');
    });

    this.dom.infoList.innerHTML = '';
    const fragment = document.createDocumentFragment();

    const top = sortItems(this.systemData);
    for (let i = 0; i < top.length; i++) {
      const item = top[i];
      const li = document.createElement('li');
      const header = document.createElement('div');
      header.className = 'info-header';
      header.textContent = `[${item.type}] ${item.name}`;
      li.appendChild(header);

      if (item.structures && item.structures.length > 0) {
        header.classList.add('collapsible');
        const sub = document.createElement('ul');
        sub.className = 'info-sublist';
        const kids = sortItems(item.structures);
        for (let k = 0; k < kids.length; k++) sub.appendChild(this.createInfoSubItem(kids[k], typeOrder));
        li.appendChild(sub);

        header.addEventListener('click', () => {
          sub.classList.toggle('visible');
          header.classList.toggle('expanded');
        });
      }

      fragment.appendChild(li);
    }

    this.dom.infoList.appendChild(fragment);
  }

  createInfoSubItem(item, typeOrder) {
    const li = document.createElement('li');
    const suffix = (item.type === 'Depot' && item.role) ? `  ${item.role}` : '';
    li.textContent = `[${item.type}] ${item.name}${suffix}`;

    if (item.structures && item.structures.length > 0) {
      const sub = document.createElement('ul');
      const kids = item.structures.slice().sort((a, b) => {
        let ai = typeOrder.indexOf(a.type);
        let bi = typeOrder.indexOf(b.type);
        if (ai === -1) ai = 99;
        if (bi === -1) bi = 99;
        if (ai !== bi) return ai - bi;
        return (a.name || '').localeCompare(b.name || '');
      });
      for (let i = 0; i < kids.length; i++) sub.appendChild(this.createInfoSubItem(kids[i], typeOrder));
      li.appendChild(sub);
    }

    return li;
  }

  populateDataList() {
    const major = [];
    const minor = [];

    const majorTypes = ['Stargate', 'Planet', 'Moon', 'Fortress', 'Large Space Station', 'Shipyard', 'Space Station'];

    const scanItem = (item) => {
      if (majorTypes.includes(item.type)) major.push(`[${item.type}] ${item.name}`);
      else if (item.type === 'Depot') {
        const role = item.role ? ` (${item.role})` : '';
        minor.push(`${item.name}${role}`);
      }
      if (item.structures) item.structures.forEach(scanItem);
    };

    this.systemData.forEach(scanItem);

    this.dom.dataList.value = [
      '--- MAJOR FEATURES ---',
      ...major.sort(),
      '',
      '--- DEPOTS & SUPPORT NODES ---',
      ...minor.sort(),
    ].join('\n');
  }

  // ---------- Editor interactions ----------

  attachObjectEvents() {
    // Make sure objects can be selected only in editor mode.
    const els = this.svg.querySelectorAll('.map-object');
    for (let i = 0; i < els.length; i++) {
      const el = els[i];
      el.onpointerdown = null;
      if (!this.editorEnabled) continue;

      el.onpointerdown = (e) => {
        e.stopPropagation();
        const id = el.getAttribute('data-obj-id');
        if (!id) return;

        // If we are placing, ignore object picks.
        if (this.placingType) return;

        this.selectObject(id);
        this.startDrag(e, id);
      };
    }
  }

  selectObject(id) {
    this.clearSelection();
    this.selectedId = String(id);

    const obj = this.objectById.get(this.selectedId);
    if (!obj) return;

    const el = this.svg.querySelector(`[data-obj-id="${this.selectedId}"]`);
    if (el) el.classList.add('selected');

    this.dom.edSelected.value = `${obj.id}`;
    this.dom.edType.value = obj.type;
    this.dom.edName.value = obj.name || '';
    this.dom.edRole.value = obj.role || '';
    this.dom.edXY.value = `${Math.round(obj.x)},${Math.round(obj.y)}`;
  }

  clearSelection() {
    const prev = this.svg.querySelector('.map-object.selected');
    if (prev) prev.classList.remove('selected');
    this.selectedId = null;
    this.dom.edSelected.value = '';
    this.dom.edName.value = '';
    this.dom.edRole.value = '';
    this.dom.edXY.value = '';
  }

  applyEditorChanges() {
    if (!this.selectedId) return;
    const obj = this.objectById.get(this.selectedId);
    if (!obj) return;

    const newType = this.dom.edType.value;
    const newName = (this.dom.edName.value || '').trim();
    const newRole = (this.dom.edRole.value || '').trim();

    if (newName) obj.name = newName;
    obj.type = newType;
    obj.role = (newType === 'Depot') ? (newRole || obj.role || '') : '';

    // Re-render to update shape by type changes.
    this.renderFromTree();

    // Rebuild index and reselect.
    this.rebuildIdIndex();
    this.selectObject(this.selectedId);
    this.populateInfoPanel();
    this.populateDataList();
  }

  deleteSelected() {
    if (!this.selectedId) return;
    const id = this.selectedId;

    const removed = this.removeNodeById(this.systemData, id);
    if (!removed) return;

    this.clearSelection();
    this.renderFromTree();
    this.rebuildIdIndex();
    this.populateInfoPanel();
    this.populateDataList();
  }

  removeNodeById(list, id) {
    for (let i = 0; i < list.length; i++) {
      const node = list[i];
      if (String(node.id) === String(id)) {
        list.splice(i, 1);
        return true;
      }
      if (node.structures && Array.isArray(node.structures)) {
        const ok = this.removeNodeById(node.structures, id);
        if (ok) return true;
      }
    }
    return false;
  }

  startDrag(e, id) {
    if (!this.editorEnabled) return;
    const obj = this.objectById.get(String(id));
    if (!obj) return;

    this.draggingId = String(id);
    const rect = this.svg.getBoundingClientRect();
    const p = this.getSvgCoords(e, rect);

    this.dragStart = { x: p.x, y: p.y };
    this.dragStartObj = { x: obj.x, y: obj.y };

    const move = (ev) => this.onDragMove(ev);
    const up = () => {
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
      this.draggingId = null;
      this.dragStart = null;
      this.dragStartObj = null;
      if (this.selectedId) {
        const o = this.objectById.get(this.selectedId);
        if (o) this.dom.edXY.value = `${Math.round(o.x)},${Math.round(o.y)}`;
      }
      this.populateDataList();
      this.populateInfoPanel();
    };

    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
  }

  onDragMove(e) {
    if (!this.draggingId || !this.dragStart || !this.dragStartObj) return;
    const obj = this.objectById.get(this.draggingId);
    if (!obj) return;

    const rect = this.svg.getBoundingClientRect();
    const p = this.getSvgCoords(e, rect);
    const dx = p.x - this.dragStart.x;
    const dy = p.y - this.dragStart.y;

    obj.x = this.dragStartObj.x + dx;
    obj.y = this.dragStartObj.y + dy;

    this.updateObjectElement(obj);
    if (this.selectedId === this.draggingId) this.dom.edXY.value = `${Math.round(obj.x)},${Math.round(obj.y)}`;
  }

  updateObjectElement(obj) {
    const el = this.svg.querySelector(`[data-obj-id="${obj.id}"]`);
    const label = this.svg.querySelector(`[data-label-for="${obj.id}"]`);
    if (!el) return;

    const meta = el.getAttribute('data-render') ? JSON.parse(el.getAttribute('data-render')) : null;
    const kind = meta && meta.renderKind ? meta.renderKind : 'circle';

    if (kind === 'circle') {
      el.setAttribute('cx', obj.x);
      el.setAttribute('cy', obj.y);
      if (label) { label.setAttribute('x', (obj.x + (meta.r || 10) + 5)); label.setAttribute('y', (obj.y + 5)); }
      return;
    }

    if (kind === 'rect') {
      const size = meta.size || 10;
      el.setAttribute('x', (obj.x - size / 2));
      el.setAttribute('y', (obj.y - size / 2));
      if (label) { label.setAttribute('x', (obj.x + size + 2)); label.setAttribute('y', obj.y); }
      return;
    }

    if (kind === 'rectWH') {
      const w = meta.w || 20;
      const h = meta.h || 10;
      el.setAttribute('x', (obj.x - w / 2));
      el.setAttribute('y', (obj.y - h / 2));
      if (label) { label.setAttribute('x', (obj.x + Math.max(w, h) + 2)); label.setAttribute('y', obj.y); }
      return;
    }

    if (kind === 'diamond' || kind === 'triangle' || kind === 'polygon') {
      const size = meta.size || 20;
      const sides = meta.sides;
      const pts = this.getPolyPoints(kind, obj.x, obj.y, size, sides);
      el.setAttribute('points', pts);
      if (label) { label.setAttribute('x', (obj.x + size + 2)); label.setAttribute('y', obj.y); }
    }
  }

  // Place new objects
  placeObjectAt(x, y, type) {
    const id = this.newId();
    const name = this.defaultNameForType(type);

    const node = { id, name, type, role: (type === 'Depot') ? 'Logistics' : '', x, y, structures: [] };
    this.systemData.push(node);

    this.renderFromTree();
    this.rebuildIdIndex();
    this.populateInfoPanel();
    this.populateDataList();

    this.selectObject(id);
  }

  defaultNameForType(type) {
    if (type === 'Depot') return this.genDepotName().name;
    if (type === 'Space Station') return this.genName(CONFIG.stationPrefixes);
    if (type === 'Shipyard') return this.genName(CONFIG.shipyardPrefixes);
    if (type === 'Large Space Station') return this.genName(CONFIG.largeStationPrefixes);
    if (type === 'Fortress') return this.genName(CONFIG.fortressPrefixes);
    if (type === 'Stargate') return (this.systemName && this.systemName !== '...') ? `${this.systemName} Stargate` : 'Stargate';
    if (type === 'Planet') {
      const root = this.choice(CONFIG.planetRoots);
      return `${root}-${(Math.floor(this.rng() * 900) + 100)} (${this.choice(CONFIG.planetTypes)})`;
    }
    if (type === 'Moon') return 'Moon Custom';
    return 'Custom Object';
  }

  // Re-render whole map from the systemData tree (used after editing/import)
  renderFromTree() {
    // Clear SVG and buffers
    Object.values(this.svgGroups).forEach(group => (group.innerHTML = ''));
    Object.keys(this.svgBuffers).forEach(k => (this.svgBuffers[k] = []));

    // Re-draw stars using current modeConfig.
    this.spatialHash.clear();
    this.placedObjects = [];
    this.generateStars(this.modeConfig);

    // Draw all objects in tree.
    const drawNode = (node) => {
      this.drawNodeObject(node);
      if (node.structures) node.structures.forEach(drawNode);
    };
    this.systemData.forEach(drawNode);

    this.renderBuffers();
    this.attachObjectEvents();
  }

  drawNodeObject(node) {
    if (!node || !node.type || typeof node.x !== 'number' || typeof node.y !== 'number') return;

    // Skip objects without ids
    if (!node.id) node.id = this.newId();

    const t = node.type;
    const x = node.x;
    const y = node.y;

    if (t === 'Planet') {
      const radius = 28;
      this.drawShape('circle', x, y, radius, { fill: '#95A5A6' }, 'planets', node.id, { renderKind: 'circle', r: radius });
      this.drawText(x + radius + 5, y + 5, node.name, false, node.id);
      return;
    }

    if (t === 'Moon') {
      const radius = 10;
      this.drawShape('circle', x, y, radius, { fill: '#cfeff7', 'fill-opacity': 0.75 }, 'planets', node.id, { renderKind: 'circle', r: radius });
      this.drawText(x + radius + 5, y + 5, node.name, true, node.id);
      return;
    }

    if (t === 'Depot') {
      const size = 8;
      this.drawShape('rect', x, y, size, { fill: this.choice(CONFIG.depotColor) }, 'depots', node.id, { renderKind: 'rect', size });
      this.drawText(x + size + 2, y, node.name, true, node.id);
      return;
    }

    if (t === 'Space Station') {
      const size = CONFIG.station.size;
      this.drawShape('rect', x, y, size, { fill: this.choice(CONFIG.stationColor), stroke: '#aabbee', 'stroke-width': 2 }, 'stations', node.id, { renderKind: 'rect', size });
      this.drawText(x + size + 2, y, node.name, false, node.id);
      return;
    }

    if (t === 'Shipyard') {
      const w = CONFIG.shipyard.w;
      const h = CONFIG.shipyard.h;
      this.drawRectWH(x, y, w, h, { fill: this.choice(CONFIG.shipyardColor), stroke: '#ffe7c2', 'stroke-width': 2 }, 'stations', node.id, { renderKind: 'rectWH', w, h });
      this.drawText(x + Math.max(w, h) + 2, y, node.name, false, node.id);
      return;
    }

    if (t === 'Large Space Station') {
      const size = CONFIG.largeStation.size;
      this.drawShape('diamond', x, y, size, { fill: this.choice(CONFIG.largeStationColor), stroke: '#d7c7ff', 'stroke-width': 2 }, 'stations', node.id, { renderKind: 'diamond', size });
      this.drawText(x + size + 2, y, node.name, false, node.id);
      return;
    }

    if (t === 'Fortress') {
      const size = CONFIG.fortress.size;
      this.drawShape('polygon', x, y, size, { fill: this.choice(CONFIG.fortressColor), stroke: '#ffaaaa', 'stroke-width': 3, sides: 5 }, 'stations', node.id, { renderKind: 'polygon', size, sides: 5 });
      this.drawText(x + size + 2, y, node.name, false, node.id);
      return;
    }

    if (t === 'Stargate') {
      const size = CONFIG.stargate.size;
      this.drawShape('triangle', x, y, size, { fill: 'none', stroke: CONFIG.stargateColor, 'stroke-width': 3 }, 'stations', node.id, { renderKind: 'triangle', size });
      this.drawText(x + size + 2, y, node.name, false, node.id);
      return;
    }
  }

  // ---------- Export / import ----------

  serializeMap() {
    // Ensure id index is current.
    this.rebuildIdIndex();

    const meta = {
      version: 1,
      seed: this.seed,
      modeKey: this.currentMode,
      systemName: this.systemName,
      systemTypeText: this.systemTypeText,
      systemAgreement: this.systemAgreement,
      viewBox: this.viewBox,
      starCenters: this.starCenters,
      triangle: this.triangle,
      createdAt: new Date().toISOString(),
    };

    // Deep copy tree to avoid accidental mutation outside.
    const dataTree = JSON.parse(JSON.stringify(this.systemData));

    return { version: 1, meta, systemData: dataTree };
  }

  exportMapFile(ext) {
    const mapObj = this.serializeMap();
    const json = JSON.stringify(mapObj, null, 2);

    const safeName = (this.systemName || 'star_system').replace(/[^a-zA-Z0-9_-]+/g, '_');
    const filename = `${safeName}.${ext}`;

    const blob = new Blob([json], { type: 'application/x-starmap+json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    URL.revokeObjectURL(url);
  }

  async handleImportFile(e) {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      const ok = this.loadMapFromObject(obj);
      if (!ok) alert('Import failed: file format not recognised.');
    } catch (err) {
      alert('Import failed: ' + (err && err.message ? err.message : String(err)));
    } finally {
      this.dom.importFile.value = '';
    }
  }

  loadMapFromObject(obj) {
    if (!obj || typeof obj !== 'object') return false;
    if (!obj.meta || !obj.systemData) return false;

    // Basic shape validation
    if (!Array.isArray(obj.systemData)) return false;

    // Apply meta
    const meta = obj.meta;
    const modeKey = meta.modeKey && CONFIG.modes[meta.modeKey] ? meta.modeKey : 'single';

    this.currentMode = modeKey;
    this.modeConfig = CONFIG.modes[modeKey];
    this.dom.systemType.value = modeKey;

    this.seed = meta.seed || '';
    this.dom.seedInput.value = this.seed || this.dom.seedInput.value;

    this.systemName = meta.systemName || 'Imported System';
    this.systemTypeText = meta.systemTypeText || '';
    this.systemAgreement = meta.systemAgreement || '';

    // Apply viewbox and star info (fallback to mode defaults)
    this.viewBox = meta.viewBox && typeof meta.viewBox === 'object' ? meta.viewBox : { ...this.modeConfig.viewBox };
    this.starCenters = Array.isArray(meta.starCenters) ? meta.starCenters : [{ x: 0, y: 0 }];
    this.triangle = meta.triangle && typeof meta.triangle === 'object' ? meta.triangle : null;

    // Replace data
    this.systemData = obj.systemData;

    // Rebuild
    this.updateViewBox();
    this.rebuildIdIndex();

    // Render
    this.renderFromTree();

    // Update description fields
    this.dom.systemNameLabel.textContent = `Name of system: ${this.systemName}`;
    this.dom.systemTypeLabel.textContent = this.systemTypeText;
    this.dom.systemAgreementLabel.textContent = this.systemAgreement;
    this.dom.systemInfoText.textContent = 'Imported map.';

    this.populateInfoPanel();
    this.populateDataList();

    return true;
  }

  // ---------- Map interaction (pan/zoom and placement) ----------

  bindMapListeners() {
    this.svg.addEventListener('pointerdown', (e) => {
      // If placing an object, only place on empty space (not on a shape)
      if (this.editorEnabled && this.placingType) {
        const target = e.target;
        const isObject = target && target.classList && target.classList.contains('map-object');
        if (!isObject) {
          const rect = this.svg.getBoundingClientRect();
          const p = this.getSvgCoords(e, rect);
          this.placeObjectAt(p.x, p.y, this.placingType);
          this.placingType = null;
          this.dom.edHint.textContent = 'Tip: Click an object to select, drag to move. Use Place then click empty space.';
          this.svg.style.cursor = 'grab';
        }
        return;
      }

      // Pan only if not editor-enabled (or if click was on background)
      if (this.editorEnabled) return;

      if (e.button !== 0) return;
      this.isPanning = true;
      this.panStartRect = this.svg.getBoundingClientRect();
      this.startPoint = this.getSvgCoords(e, this.panStartRect);
      this.svg.style.cursor = 'grabbing';
    });

    const stopPan = () => {
      this.isPanning = false;
      this.svg.style.cursor = 'grab';
      this.panStartRect = null;
      if (this.rafId) { cancelAnimationFrame(this.rafId); this.rafId = null; }
    };

    this.svg.addEventListener('pointerup', stopPan);
    this.svg.addEventListener('pointerleave', stopPan);

    this.svg.addEventListener('pointermove', (e) => {
      if (!this.isPanning) return;
      if (this.rafId) return;

      this.rafId = requestAnimationFrame(() => {
        const p = this.getSvgCoords(e, this.panStartRect);
        this.viewBox.x += (this.startPoint.x - p.x);
        this.viewBox.y += (this.startPoint.y - p.y);
        this.updateViewBox();
        this.rafId = null;
      });
    });

    this.svg.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = this.svg.getBoundingClientRect();
      const m = this.getSvgCoords(e, rect);
      const f = e.deltaY < 0 ? 0.9 : 1.1;
      this.viewBox.x = m.x - (m.x - this.viewBox.x) * f;
      this.viewBox.y = m.y - (m.y - this.viewBox.y) * f;
      this.viewBox.w *= f;
      this.viewBox.h *= f;
      this.updateViewBox();
    }, { passive: false });
  }

  toggleLabels() {
    this.labelsVisible = !this.labelsVisible;
    this.svgGroups.labels.style.display = this.labelsVisible ? '' : 'none';
  }

  updateViewBox() {
    this.svg.setAttribute('viewBox', `${this.viewBox.x} ${this.viewBox.y} ${this.viewBox.w} ${this.viewBox.h}`);
  }

  getSvgCoords(e, rect) {
    const r = rect || this.svg.getBoundingClientRect();
    const rx = this.viewBox.w / r.width;
    const ry = this.viewBox.h / r.height;
    return {
      x: this.viewBox.x + (e.clientX - r.left) * rx,
      y: this.viewBox.y + (e.clientY - r.top) * ry,
    };
  }

  // ---------- RNG / collisions / placement ----------

  seededRNG(seed) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < seed.length; i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
    let s = h;
    return () => {
      s = (Math.imul(48271, s) % 2147483647);
      return (s & 0x7fffffff) / 2147483647;
    };
  }

  choice(arr) { return arr[Math.floor(this.rng() * arr.length)]; }

  collides(x, y, r) {
    const rr = r + 15;
    const candidates = this.spatialHash.getCandidates(x, y);
    for (let i = 0; i < candidates.length; i++) {
      const o = candidates[i];
      const dx = x - o.x;
      const dy = y - o.y;
      const distSq = dx * dx + dy * dy;
      const rad = rr + o.r;
      if (distSq < rad * rad) return true;
    }
    return false;
  }

  reserve(x, y, r) {
    this.placedObjects.push({ x, y, r });
    this.spatialHash.add(x, y, r);
  }

  findOpenSpot(cx, cy, radius, minRange, rangeVariance, maxTries = 20) {
    const r0 = Math.max(0, minRange);
    const r1 = Math.max(r0 + 1, minRange + Math.max(0, rangeVariance));
    const r0sq = r0 * r0;
    const r1sq = r1 * r1;

    let tries = 0;
    let x, y;
    do {
      const angle = this.rng() * Math.PI * 2;
      const u = this.rng();
      const dist = Math.sqrt(u * (r1sq - r0sq) + r0sq);
      x = cx + Math.cos(angle) * dist;
      y = cy + Math.sin(angle) * dist;
      tries++;
    } while (this.collides(x, y, radius) && tries < maxTries);

    if (tries < maxTries) {
      this.reserve(x, y, radius);
      return { x, y };
    }
    return null;
  }

  // ---------- Naming ----------

  genDesignation() {
    const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
    return (Math.floor(this.rng() * 9000) + 1000) + this.choice(letters);
  }

  genName(prefixList) {
    const prefix = this.choice(prefixList);
    return `${prefix}-${this.genDesignation()}`;
  }

  genDepotName(preferredRole = null) {
    let roleObj = null;
    if (preferredRole) roleObj = CONFIG.depotRoles.find(r => r.role === preferredRole) || null;
    if (!roleObj) roleObj = this.choice(CONFIG.depotRoles);
    const prefix = this.choice(roleObj.prefixes);
    return { name: `${prefix}-${this.genDesignation()}`, role: roleObj.role };
  }

  // ---------- SVG drawing ----------

  createEl(tag, attributes) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for (const k in attributes) el.setAttribute(k, attributes[k]);
    return el;
  }

  drawText(x, y, txt, small = false, forId = null) {
    const fontSize = small ? 9 : 11;
    const fill = small ? '#aab8c0' : '#cfeff7';
    const dataAttr = forId ? ` data-label-for="${String(forId)}"` : '';
    this.svgBuffers.labels.push(`<text${dataAttr} x="${x}" y="${y}" font-size="${fontSize}" fill="${fill}">${this.escapeXml(txt)}</text>`);
  }

  drawOrbit(radius, cx = 0, cy = 0) {
    this.svgBuffers.orbits.push(`<circle cx="${cx}" cy="${cy}" r="${radius}" fill="none" stroke="rgba(255,255,250,0.05)" />`);
  }

  drawRectWH(cx, cy, w, h, attrs = {}, groupName, objId, renderMeta) {
    let s = `<rect class="map-object" data-obj-id="${String(objId)}" data-render='${JSON.stringify(renderMeta || {}).replace(/'/g, '&apos;')}' x="${cx - w / 2}" y="${cy - h / 2}" width="${w}" height="${h}"`;
    for (const [k, v] of Object.entries(attrs)) s += ` ${k}="${v}"`;
    s += ' />';
    this.svgBuffers[groupName].push(s);
  }

  drawShape(type, x, y, r, attrs = {}, groupName, objId, renderMeta) {
    // When objId is null, draw a non-interactive shape.
    const interactive = objId !== null && objId !== undefined;
    const cls = interactive ? ' class="map-object"' : '';
    const idAttr = interactive ? ` data-obj-id="${String(objId)}"` : '';
    const metaAttr = interactive ? ` data-render='${JSON.stringify(renderMeta || {}).replace(/'/g, '&apos;')}'` : '';

    let shapeStr = '';
    const shapeAttrs = { ...attrs };

    if (type === 'circle') {
      shapeStr = `<circle${cls}${idAttr}${metaAttr} cx="${x}" cy="${y}" r="${r}"`;
    } else if (type === 'rect') {
      shapeStr = `<rect${cls}${idAttr}${metaAttr} x="${x - r / 2}" y="${y - r / 2}" width="${r}" height="${r}"`;
    } else if (type === 'polygon' || type === 'triangle' || type === 'diamond') {
      const points = this.getPolyPoints(type, x, y, r, shapeAttrs.sides);
      shapeStr = `<polygon${cls}${idAttr}${metaAttr} points="${points}"`;
    } else {
      return;
    }

    delete shapeAttrs.sides;
    for (const [k, v] of Object.entries(shapeAttrs)) shapeStr += ` ${k}="${v}"`;
    shapeStr += ' />';

    this.svgBuffers[groupName].push(shapeStr);
  }

  getPolyPoints(type, x, y, r, sides) {
    if (type === 'triangle') return `${x},${y - r} ${x + r * 0.866},${y + r * 0.5} ${x - r * 0.866},${y + r * 0.5}`;
    if (type === 'diamond') return `${x},${y - r} ${x + r},${y} ${x},${y + r} ${x - r},${y}`;

    const pts = [];
    const numSides = sides || 6;
    const angleOffset = (numSides === 6) ? -(Math.PI / numSides) : 0;

    for (let i = 0; i < numSides; i++) {
      const ang = (Math.PI * 2 * i / numSides) + angleOffset;
      pts.push((x + r * Math.cos(ang)) + ',' + (y + r * Math.sin(ang)));
    }
    return pts.join(' ');
  }

  escapeXml(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }
}

function runTests() {
  const assert = (cond, msg) => { if (!cond) throw new Error('Test failed: ' + msg); };

  const mockSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  const mk = (tag) => document.createElement(tag);

  const g = new StarSystemGenerator(mockSvg, {
    seedInput: mk('input'),
    systemType: mk('select'),
    generateBtn: mk('button'),
    randomSeedBtn: mk('button'),
    toggleLabelsBtn: mk('button'),
    infoToggleBtn: mk('button'),
    infoPanel: mk('div'),
    infoList: mk('ul'),
    dataList: mk('textarea'),
    systemNameLabel: mk('h2'),
    systemTypeLabel: mk('span'),
    systemAgreementLabel: mk('span'),
    systemInfoText: mk('p'),
    editorBtn: mk('button'),
    exportBtn: mk('button'),
    importBtn: mk('button'),
    importFile: mk('input'),
    editorPanel: mk('div'),
    edSelected: mk('input'),
    edType: mk('select'),
    edName: mk('input'),
    edRole: mk('input'),
    edXY: mk('input'),
    edSaveBtn: mk('button'),
    edDeleteBtn: mk('button'),
    edAddType: mk('select'),
    edPlaceBtn: mk('button'),
    edHint: mk('small'),
  });

  // Deterministic RNG
  const r1 = g.seededRNG('S123');
  const r2 = g.seededRNG('S123');
  assert(r1() === r2(), 'seededRNG should be deterministic for same seed');

  // Map serialise + load round-trip
  g.seed = 'S123';
  g.currentMode = 'single';
  g.modeConfig = CONFIG.modes.single;
  g.systemName = 'TestSystem';
  g.systemTypeText = 'Star System';
  g.systemAgreement = 'Star System Development Agreement';
  g.systemData = [
    { id: '1', name: 'Alpha (Oceanic)', type: 'Planet', x: 100, y: 50, role: '', structures: [
      { id: '2', name: 'Depot-1000A', type: 'Depot', x: 120, y: 60, role: 'Logistics', structures: [] },
    ] },
    { id: '3', name: 'Outpost-2000B', type: 'Space Station', x: -40, y: 10, role: '', structures: [] },
  ];

  const mapObj = g.serializeMap();
  assert(mapObj.version === 1, 'map version should be 1');
  assert(mapObj.meta && mapObj.meta.modeKey === 'single', 'meta should contain modeKey');
  assert(Array.isArray(mapObj.systemData), 'systemData should be an array');

  const g2 = new StarSystemGenerator(mockSvg, g.dom);
  const ok = g2.loadMapFromObject(mapObj);
  assert(ok === true, 'loadMapFromObject should succeed');
  assert(g2.systemName === 'TestSystem', 'systemName should round-trip');

  // Editor methods exist
  assert(typeof g.toggleEditor === 'function', 'toggleEditor should exist');
  assert(typeof g.exportMapFile === 'function', 'exportMapFile should exist');
  assert(typeof g.loadMapFromObject === 'function', 'loadMapFromObject should exist');

  console.log('All tests passed.');
}

document.addEventListener('DOMContentLoaded', () => {
  const domElements = {
    svg: document.getElementById('map'),
    infoList: document.getElementById('infoList'),
    dataList: document.getElementById('generatedDataList'),
    seedInput: document.getElementById('seedInput'),
    systemType: document.getElementById('systemType'),
    generateBtn: document.getElementById('generateBtn'),
    randomSeedBtn: document.getElementById('randomSeedBtn'),
    toggleLabelsBtn: document.getElementById('toggleLabelsBtn'),
    infoPanel: document.getElementById('infoPanel'),
    infoToggleBtn: document.getElementById('infoToggleBtn'),
    systemNameLabel: document.getElementById('systemNameLabel'),
    systemTypeLabel: document.getElementById('systemTypeLabel'),
    systemAgreementLabel: document.getElementById('systemAgreementLabel'),
    systemInfoText: document.getElementById('systemInfoText'),

    editorBtn: document.getElementById('editorBtn'),
    exportBtn: document.getElementById('exportBtn'),
    importBtn: document.getElementById('importBtn'),
    importFile: document.getElementById('importFile'),

    editorPanel: document.getElementById('editorPanel'),
    edSelected: document.getElementById('edSelected'),
    edType: document.getElementById('edType'),
    edName: document.getElementById('edName'),
    edRole: document.getElementById('edRole'),
    edXY: document.getElementById('edXY'),
    edSaveBtn: document.getElementById('edSaveBtn'),
    edDeleteBtn: document.getElementById('edDeleteBtn'),
    edAddType: document.getElementById('edAddType'),
    edPlaceBtn: document.getElementById('edPlaceBtn'),
    edHint: document.getElementById('edHint'),
  };

  const generator = new StarSystemGenerator(domElements.svg, domElements);
  generator.init();

  window.__STAR_SYSTEM_GENERATOR__ = generator;
  window.__RUN_TESTS__ = runTests;
});
</script>
</body>
</html>
